<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
</head>

<body>
    <script>
        alert('Hello world'); //얼럿으로 Hello World 띄우는 방법
        console.log("Hello World"); //콘솔창에 Hello World 띄우는 방법

        // 변수
        var a = 0, b = 1; // JS에서 변수는 모두 var로 선언한다.(수, 문자 모두 가능)
        a = 1; alert(a); // ;의 사용법: 독립된 명령으로 구분하기 위해 ;으로 표기(동일한 줄이어도 ;를 통해 서로 다른 명령임을 구분시켜 표기할 수 있다.)

        // 수학 연산
        Math.pow(3, 2); //pow    (power):제곱 연산
        Math.round(10.7); //round   (round):반올림 연산
        Math.ceil(10.3); //ceil    (ceil):올림 연산
        Math.floor(10.3); //floor   (floor):내림 연산
        Math.sqrt(9); //sqrt    :제곱근 연산
        Math.random(); //random    :랜덤 수 제공, 소수점 형태로 제공되므로 '*숫자'를 통해 "숫자"보다 작은 수 중 랜덤 값을 반환할 수 있다.
        Math.round(100 * Math.random()); //100보다 작은 수 중 정수를 반환   

        // 문자 연산
        //""와 ''는 동일한 역할을 하며, "과 '를 구분하기 위해 두가지를 혼합해서 사용할 수 있다.
        alert('Againyunn\'s coding time') // \ escape문자:      뒤의 기호는 특정 \바로 뒤의 문자는 '정보'로 자동 해석
        alert("coding \ntime") // \n    :줄바꿈 

        typeof "변수" // typeof     :뒤에 위치한 변수의 type을 나타내는 함수

        "변수".length // .length    :해당 변수의 인덱스 수를 반환
        "변수".indexOf("수")// .indexOf("인덱스의 원소")    :입력받은 "인덱스의 원소"의 index를 반환

        //동등 비교 연산자( === 사용하는 것이 바람직하다.)
        //  ==      :동등 연산자(equal operator) 값이 같은 지 확인
        //  ===     :일치 연산자(strict equal operator) 값 & data type 모두 정확히 같은 지 확인
        alert(1 === '1'); // === 연산자로 1과 '1'의 type이 다르므로 false 반환

        // null과 undefinded의 차이
        //undefinded     :값이 정의되지 않은(프로그래머가 의도적으로 비운 값x), null   :값이 없음(프로그래머가 의도적으로 값을 미지정)

        alert(null == undefined); // true
        alert(null === undefined); // false

        alert(true == 1); // ==     :1을 true 값으로 간주
        alert(true == '1'); // ==   :'1'도 ture 값으로 간주

        alert(0 === -0); // true    :0과 -0은 둘 다 동일한 값이므로 ===을 사용해도 true 반환
        alert(NaN === NaN); //NaN   :0/0의 연산결과 시 operator error data type을 의미

        // 동등 비교 연산자 ==와 === 비교:
        // https://dorey.github.io/JavaScript-Equality-Table/

        //부정 비교 연산자
        //  !=      :부정 비교 연산자(not equal operator) 값이 다른 지 확인
        //  !==     :부정 일치 연산자(strict not equal operator) 값 & data type 모두 정확히 다른 지 확인

        //조건문(conditional statement)
        var c = null;
        if (c !== 1) {
            alert('result : c == 1');
        }
        else if (c === 2) {
            alert('result : c == 2');
        }
        else {
            alert('result : c == null');
        }

        // 웹 브라우저에 프롬프트 창이 뜨면서 "입력란"이 생성된다.
        prompt('당신의 나이는?');
        alert(prompt('당신의 나이는?') * 2);

        // 활용 예시
        // id를 입력받고 
        var id = prompt('id를 입력해주세요.');
        var pw = prompt('pw를 입력해주세요.')
        if (id === 'againyunn') {
            alert('아이디가 일치합니다.');
            if (pw === '6096') {
                alert('로그인되었습니다.' + id + '님 반갑습니다.');
            }
            else {
                alert('패스워드를 다시 입력해주세요.');
            }
        }
        else {
            alert('아이디를 다시 입력해주세요.');
        }

        // 논리 연산자
        // &&   :and 연산자
        // ||   :or 연산자
        // !    :not 연산자(부정연산자)

        // 1            :true로 간주
        // 그 외 수     :false로 간주

        if ('') { alert('빈문자열'); } // JS는 ''를 false로 간주
        if (undefined) { alert('undefined'); } // JS는 undefined를 false로 간주

        // 반복문  변수 i (iterator)
        // while
        var i = 0;
        while (i < 10) {
            document.write("Hello World " + i + "<br/>"); // JS코드 내에서 작성된 내용을 웹 페이지에 출력해주는 함수
            i += 1;
        }

        // for
        for (var i = 0; i < 10; i++) {
            if (i === 5) {
                continue; // 반복문은 지속 + 아래의 코드 실행x
                break; // 반복문 자체를 탈출
            }
        }

        for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 10; j++) {
                if (10 * i + j > 95) {
                    break;
                }
                document.write("Hello World " + i + j + "<br/>"); // JS에서 문자+숫자+문자 일 때(문자 사이에 숫자가 끼어 있을 때,) 숫자를 '문자'로 인식한다.
            }
        }

        // function     :함수(여러 입력 가능 but 값 반환은 1개만 가능)
        // 함수에서 값을 받는 변수  :매개변수
        // 함수에서 입력받는 값     :인자

        // 방법1:   일반적 호출
        function numbering1(arg1, arg2) {
            document.wirteln(1);
            arg1 *= 1000
            arg2 *= 100
            return arg1 + arg2;
        }
        numbering1(2, 3); // 함수 호출

        // 방법2:   변수에 함수를 정의
        numbering2 = function (arg1, arg2) {
            document.wirteln(1);
            arg1 *= 1000
            arg2 *= 100
            return arg1 + arg2;
        }
        numbering2(2, 3); // 함수 호출

        // 방법3:   익명함수(이름 없이 바로 실행하기 위한 함수)
        (function (arg1, arg2) {
            document.wirteln(1);
            arg1 *= 1000
            arg2 *= 100
            return arg1 + arg2;
        })();

        // 배열(array)
        var member = ['a', 'b', 'c'];

        function get_member() {
            return ['a', 'b', 'c']; // 함수에서 '배열'자체를 반환할 수도 있다.
        }
        member = get_member(); // 함수의 결과 '배열 값'을 변수로 저장하여 사용할 수도 있다.
        document.write(member[0]);
        document.write(member[1]);
        document.write(member[2]);

        // toUpperCase      :대문자로 변환 함수
        for (var i = 0; i < member.length; i++) {
            document.write(i.toUpperCase() + "<br/>");
        }

        // .length      :배열의 길이(인덱스 수)반환

        // 배열(array)에 원소 추가
        // .push()      :특정 element를 배열 마지막에 추가
        // .concat()    :concatination(결합하다) 다수의 elements를 배열 마지막에 추가
        // .unshift()   :특정 element를 배열 가장 앞에 추가(기존의 인덱스가 1씩 뒤로 밀린다.)
        // .splice(인덱스 위치, 인덱스 중 삭제할 원소의 수(0으로 적으면 삭제 없이 새 원소를 추가한다는 의미), 추가할 원소1, 추가할 원소2 ... )
        member.splice(2, 0, 'd', 'e')   // member의 배열 내 원소들      :['a', 'b', 'c', 'd', 'e']
        member.splice(0, 1, 'A')    // member의 배열 내 원소들      :['A', 'b', 'c', 'd', 'e']

        // 배열(array)에 원소 삭제
        // .shift() :배열의 첫번째 원소를 삭제
        // .pop()   :배열의 마지막 원소를 삭제

        // .sort()  :오름차순 정렬
        // .reverse()   :내림차순 정렬

        // 객체의 생성
        // 딕셔너리{key: value} 형태로 정의
        var grades = { 'aaa': 10, 'bbb': 20, 'ccc': 30 };

        var classNum = {}; // 객체를 null값으로 우선 data type만 지정
        classNum['a'] = 10;
        classNum['b'] = 20;
        classNum['c'] = 30;

        // 객체 호출
        // 방법1:
        classNum['a']
        // 방법1의 장점:
        calssNum['a' + 'aa'] // 이처럼 index 내의 key값을 연산을 통해 지정해도 해당 값을 불러올 수 있다.

        // 방법2:
        classNim.a // .으로 해당 객체의 메소드(변수)를 사용하는 경우에는 index의 key값을 연산을 통해 지정할 수 없다.
    </script>

    <!-- html 내에서 JS를 활용하는 방법 -->
    <ul>
        <script>
            // 반복문 + 객체(딕셔너리) 활용
            for (key in grades) { // grade의 key값들을 순차적으로 불러오라는 의미
                document.write("<li>key : " + key + " value : " + grades[key] + "</li>"); // html태그 <li></li> 안에 각 값들을 출력하도록 하여 html로 값을 반환하는 역할을 한다.
            }

            gradeArray=['A', 'B', 'C']
            // 반복문 + 객체(배열) 활용
            for (name in gradeArray) { // grade의 key값들을 순차적으로 불러오라는 의미
                document.write("<li>grade : " + gradeArray[name] + "</li>"); // html태그 <li></li> 안에 각 값들을 출력하도록 하여 html로 값을 반환하는 역할을 한다.
            }
        </script>
    </ul>

    <script>
        // 객체 안에는 여러 객체와 함수가 담겨있을 수 있다.(2차원 배열의 형태로 존재 가능)
        var grades = {
            'list' : {'a': 10, 'b': 20, 'c': 30},

            // JS는 '함수형 프로그래밍'으로 함수도 변수와 같은 "객체"로 인지한다. 따라서 함수는 객체 내부에 포함되거나, 함수가 객체가 될 수 있다.
            'show' : function(){
                alert('Hello World');
            },


            // JS에서 this는 해당 객체 자체를 나타내는 값이다. 즉, this를 활용하여 자기 자신(self)를 불러올 수 있다.
            'grade_self' : function(){ 
                alert(this.list) // grades 객체의 list 값을 반환하라는 의미

                for(var name in this.list){
                    console.log(neme, this.list[name]);
                }
            }
        }

        // 어떠한 경우에도 함수(메소드)는 ()으로 둘러서 적는다.
        alert(grades['show']()); // 객체 grades 안의 show(key)가 호출되었으므로 show에 대응하는 value인 함수가 반환된다.(함수 값이므로, ()로 호출)
        alert(grades.grade_self());

    </script>

</body>

</html>