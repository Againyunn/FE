JS 기본적인 활용

JS는 html과 연결될 때, class 단위가 아니라, 특정 HTML element에 적용할 때 주로 "getElementById("아이디 명")"의 형태로 "id"기준으로 HTML element를 호출한다.
그러므로, head / body 어디에 JS코드가 위치하든 <script>  </script> 태그 사이에 코드들을 정의하고 getElementById("아이디 명")으로 HTML element와 연결한다.

output
- display할 수 있는 방법:
    1) innerHTML        :HTML 엘리먼트 안에 특정 내용을 JS 코드로 직접 입력
    2) document.write() :해당 코드가 위치한 곳에 JS 코드로 직접 입력 → <script> 가 body에 선언되었을 때도 사용할 수 있으며, 여러 HTML tag에 이어서 JS코드가 선언된 위치에 값을 바로 반환
        * HTML 엘리먼트가 생성 된 후 document.write()을 사용하면 생성된 HTML 의 모든 엘리먼트가 삭제되고 JS코드로 작성한 내용만 표기된다.(ex : onclick 메서드와 같은 애트리뷰트 이용 시)

    3) window.alert()   :브라우져의 "알림창"으로 JS코드로 입력된 값을 반환
    4) console.log()    :브라우져의 "콘솔 창"으로 JS코드로 입력된 값을 반환

* JS는 python, java, C등과 다르게 자체적인 "print()"메서드가 없다.
    window.print() 는 웹 페이지를 인쇄한다는 명령어

JS 주요 제어자
    Keyword	    Description
    var	        변수 재선언 가능, 재할당 가능(orriding 가능)
    let	        변수 재선언 불가, 재할당 가능(orriding 가능)
    const	    변수 재선언 불가, 재할당 불가능
    if	        조건문
    switch	    switch문
    for	        반복문
    function	함수 정의
    return	    함수 종료 및 반환 값
    try	        예외처리 블럭

variables
* 블럭 선언 불가능
재선언 가능
    ex) var x = 5; var x = 6; 

재할당 가능
    ex) var x = 0; x =5;

let
* 블럭으로 선언가능 {} 사용가능
재선언 불가능  
    ex) let x = 6; let x = 7;      //Syntax error 발생

재할당 가능
    ex) let x = 0; x = 5;       

const
* 블럭으로 선언가능 {} 사용가능
재선언 불가능
재할당 불가능 
* 처음 선언할 때의 형태 그대로만 사용가능

연산자 및 증감자는 JAvA와 동일(축약 연산자도 동일)

data types
python처럼 변수의 데이터형을 프로그램이 알아서 해석

주요 특징:
    1) 타 언어와 마찬가지로, 숫자+String(문자/문자열) = 모두 문자열로 바꾸어 연산한다.
    2) 연산에 순서가 존재(동일한 내용이더라도 순서가 다르면 결과가 달라질 수 있다.)
        ex) 
            경우1: let x = 16 + 4 + "Hello"     //"20Hello"
            경우2: let x = "Hello" + 16 + 4     //"Hello164"
        
function
1) 함수 자체로 선언하기
    function myWorld(a, b){
        ...
        return 
    }
2) 변수에 함수 생성
    const myWorld=(a, b) => {
        ...
        return
    }

object(객체)
* 일반적으로 "객체" 선언 시에는 const를 사용한다.

* 객체 내의 여러 값들을 지정할 경우 python의 dictionary와 유사하게 선언(python → car = {type: "Fiat", model: "500", color: "white"})
자료형 변수명 = {name1:"value1", name2:"value2"...}
ex) 
    const car = {type: "Fiat", model: "500", color: "white"};

accessing object properties에 접근하는 방법
방법1:
    objectName.propertyName

방법2:
    objectName["propertyName"]

* 타 언어와 다른 점은 "객체(상수, 변수)"에 "함수"를 담을 수 있다는 점
ex) 
    cosnt oneMan={
        firstName: "John",
        lastName: "Joe",
        id: 0523;
        fullName : fuction(){
            return this.firstName + " " + this.lastName;    // this를 통해서 해당 객체 내부에 선언된 변수를 재귀대명사처럼 지칭가능(Java의 this와 동일)
        }
    }

accessing object methods
방법:
    objectName.methodName()         //타 언어와 동일

* 주의:
    String, Number, Boolean 등의 객체의 데이터형을 변수에 선언하기x → 프로그램의 실행속도가 늦어지게 만들 수 있다.
    ex) x = new String(); // 이런식으로 선언x


HTML event 사용하기
HTML tag 내부에서 사용:
    <element event = "JS 코드"> 형식으로 사용

자주사용하는 HTML events
    Event	            Description
    onchange	        html 엘리먼트가 바뀌었을 때
    onclick	            html 엘리먼트를 클릭했을 때
    onmouseover	        html 엘리먼트에 마우스를 올렸을 때
    onmouseout	        html 엘리먼트에 마우스를 댔다가 떼었을 때
    onkeydown	        사용자가 키보드 자판을 눌렀을 때
    onload	            브라우져가 로딩을 다 끝냈을 때(페이지 생성을 다 끝냈을 때)

string
""와 ''를 모두 사용가능
    ex) let a = "It's a apple.";

길이 메서드
    string객체.length       //Java와 동일

인용문자 표기
    Code	Result	Description
    \'	    '	    Single quote
    \"	    "	    Double quote
    \\	    \	    Backslash

escape sequences
* html에서는 사용x, 주로 백그라운드 프로그램의 연산, 함수에 이용
    Code	Result
    \b	    Backspace
    \f  	Form Feed
    \n	    New Line
    \r	    Carriage Return
    \t	    Horizontal Tabulator
    \v	    Vertical Tabulator

string methods
1) extracting string parts(string의 일부를 추출)
    slice(start, end)
        시작~ 끝까지의 "문자열 index"를 입력
    
    substring(start, end)
        시작~ 끝까지의 "문자"를 입력(부문자열 입력)

    substr(start, length)
        시작의 indext와 길이(index길이)를 입력
    
2) replacing string content(string를 수정)
    string문자열.replace("변경의 대상", "변경할 대상")
    * replace 메서드는 해당 string의 원형을 변경하지 않는다. 변경된 것을 반환만 한다. 그러므로 반환된 객체를 받을 변수가 필요하다.
    * 소문자/대문자의 형태로 동일하게 맞춰야 한다.
    ex)
        let text = "We'll take yellow";
        let newText = text.replace("yellow", "skyblue")
    * 정규식을 통해 조건을 구체화할 수 있다.
    ex) 
        let text = "We'll take yellow!";
        let newText = text.replace("/yellow/g", "skyblue")  // /ge  : 뒤에 문자가 더 있는 경우로 제한

3) 대/소문자 변경
    toUpperCase()   :대문자로 변경
    toLowerCase()   :소문자로 변경

4) 공백 없애기
    trim()      :해당 string 내부의 공백을 없앤다

5) extracting string charactors(문자만을 추출)  
    charAt(indexNum)
        해당 인덱스에 해당하는 문자를 반환 

    charCodeAt(indexNum)
        해당 인덱스에 해당하는 문자의 unicode를 반환

6) string split(문자열을 구분하여 배열로 저장)  
    문자열.split("구분할 방식")
        ex)
            let nums= "0, 1, 2, 3, 4, 5";
            const numsArray= nums.split(", ");
            console.log(numsArray[1]);          // 1 반환           
    
        ex)
            let hello="Hello";
            const helloArray= hello.split("");
            console.log(helloArray[1]);          // e 반환

string search
1) indextOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 첫번째 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)
    ex)     
        let str = "Please locate where 'locate' occurs!";
        str.indexOf("locate");

2) lastIndexOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 마지막 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)

3) search()
    indexOf와 거의 동일한 역할 수행

4) match()
    입력받은 문자와 동일한 문자가 해당 문자에 있는 지 확인하고 존재하면 입력받은 문자들 배열의 형태로 반환
    ex) 
        let text = "The rain in SPAIN stays mainly in plain.";
        text.match(/ain/g);         // ain,ain,ain

5) includes()
    입력받은 문자가 해당 문자에 존재하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.includes("world");             // true

6) startsWith()
    입력받은 문자로 해당 문자열이 시작하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.startsWith("Hello");           // true

7) endsWith()
    입력받은 문자로 해당 문자열로 끝는 지 여부를 판별(true / false)
    ex)
        var text = "John Doe";
        text.endsWith("Doe");               // true

template literals
    표현식:
        ` 문자(열) ` 
    활용:
        1) 문자열 "" 나 '' 대신 사용 가능
        2) 문자열 내부에 "" 나 ''를 제약 없이 사용가능
        3) 문자열이지만, 줄 바꿈을 허용
        4) 변수의 format 서식자 사용가능
            ex)
                let firstName = "John";
                let lastName = "Doe";   
                let text = `Welcome ${firstName}, ${lastName}!`;
        5) 문자열 내부의 변수간 연산을 허용
            ex)
                let price = 10;
                let VAT = 0.25;
                let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;
        6) HTML tag(element)도 직접 사용가능
            ex)
                let header = "Templates Literals";
                let tags = ["template literals", "javascript", "es6"];

                let html = `<h2>${header}</h2><ul>`;
                for (const x of tags) {

                html += `<li>${x}</li>`;
                }

                html += `</ul>`;

number
* number와 string 간 덧셈 연산을 해도, 이를 string간의 연산으로 간주한다.
ex) let x = "10";
    let y = 20;
    let z = x + y; // 1020

* 그 외의 연산은 string을 number로 compile한 뒤 연산한다.

무한    :infinity

number methods
1) toString()
    숫자를 문자로 전환
    ex) let x = 523;
        x.toString();

    ex) (123).toString();
        (100 + 23).toSting();

2) toFixed()
    소수점 자리를 고정
    ex) let x = 9.656;
        x.toFixed(0);   //9
        x.toFixed(2);   //9.65
        x.tofixed(4);   //9.6560

3) toExponential()
    소수점 특정 자리에서 "반올림"
    ex) let x = 9.656;
        x.toExponential(0);   //9
        x.toExponential(2);   //9.65
        x.toExponential(4);   //9.6560

4) Number()
    객체를 "수"로 변환

5) parseFloat()
    객체를 실수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

6) parseInt()
    객체를 정수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

7) max()
    입력받은 숫자 중 가장 큰 수를 반환

8) min()
    입력받은 숫자 중 가장 작은 수를 반환

array
* 배열은 주로 const를 활용한다.
    ex)
        const color = ["white", "green", "yellow"];

그 외의 기본적인 array관련 문법은 타 언어와 동일

HTML tag 내부에 자동으로 ,를 생성하여 출력된다.
ex)
    const color = ["white", "green", "yellow"];
    document.getElementById("root").innerHTML = color;  //white, green, yellow

배열 내의 원소(index) 간 datatype이 달라도 된다.
    ex)
        const person = ["John", "Lucas" , 26];  // 이렇게 넣어도 오류 발생x

array 내부에 object(객체)를 넣을 수 있다.
    1) 객체+메서드 넣기
        ex) myArray[0] = Date.now;
    
    2) 함수 넣기
        ex) myArray[1] = myFunction;    //function 함수 넣기
    
    3) 객체 넣기
        ex) myArray[2] = myCars;    //object 객체 넣기

array(배열) vs object(객체)
    * 둘의 가장 큰 차이: 호출 방식이 배열은 "number index", 객체는 "named index"
    array:    const person = ["John", "Lucas" , 26];
    호출방법:   cosnt result = person[0];   //John

    object:   const person = {firstName: "John", nickName: "Lucas", age: 26};   //python 의 dictionary와 유사
    호출방법:   const result = person.firstName;    //John

adding array elements
    const fruits = ["Banana", "Orange" ,"Apple"];
    fruits.push("Lemon");   // stack이나 queue처럼 push를 통해 새로운 원소가 배열의 맨 끝에 추가된다.

* JS가 인식하는 array의 타입
    typeOf 메서드 활용 →  object로 반환한다.


array method
1) toString()
    배열의 원소들을 모아, 문자열로 반환(각 원소 사이에 ,를 자동삽입)

    ex)
        const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.toString();      //Banana,Orange
        // toString메서드 내부에 넣지 않고, 객체의 메서드로 적용(인자 넣지x)
    
2) join()
    배열의 원소들을 모아, 각 인덱스별로 특정 문자를 넣어 문자열로 반환
    
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.join(" * ");      //Banana * Orange
        // python의 join과 동일한 역할 수행

3) pop()
    배열의 가장 마지막 원소를 삭제 후 반환(pop의 내부 인자로 값을 넣어도, 해당 배열의 마지막 원소만을 삭제 후 반환)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.pop(); 

4) push()
    배열의 가장 마지막 원소로 새로운 원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.push("Mango");

5) shift()
    배열의 가장 첫번째 원소를 삭제하고 모든 원소들의 index를 하나씩 당기고, 재조합된(첫번째 원소가 삭제된)배열을 반환(삭제된 배열의 index를 빈값으로 유지x)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.shift();     //Orange

6) unshift()
    배열의 첫번째 인덱스에 특정원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.unshift("Mango");     //Mango,Banana,Orange

7) length
    배열의 원소 수를 반환
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.length; //2

8) concat()
    배열끼리의 병합
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        cosnt myChildren = myGirls.concat(myBoys);  //Cecile,Lone,Emil,Tom
    
    * 여러 개의 배열을 한번에 병합도 가능하다.
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        const myPuppy = ["guembee"]
        cosnt myChildren = myGirls.concat(myBoys, myPuppy);  //Cecile,Lone,Emil,Tom,guembee

9) splice()
    형식:   splice(추가할 인덱스 위치, 삭제할 원소 수, 추가할 원자들1, 추가할 원자들2 ...)
    * 원본 array의 원소에 영향을 미친다.
    
    특정 위치에 원소 삽입
    ex) 
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 0, "Lemon", "Kiwi");   //Banana,Orange,Lemon,Kiwi,Apple,Mango

    특정 위치의 원소 삭제
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 2, "Lemon", "Kiwi");   //Orange,Apple,Mango
    
10) slice
    * 원본 array에 영향x, 새롭게 변경된 array를 생성하여 반환
    * 자를 위치의 인덱스 앞까지의 원소들을 새로운 array로 생성하여 반환
    형식:   slice(자를 인덱스 번호)

    ex)
        const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
        const citrus = fruits.slice(1); //Banana
        //  원본 배열인 fruits는 그대로 존재, 새롭게 생성된 배열 citrus만 생성

11) sort()
    오름차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.sort();      //Apple,Banana,Mango,Orange

    숫자의 오름차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return a - b});  // 1,5,10,25,40,100
    
    숫자의 내림차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return b - a});  // 100,40,25,10,5,1

12) reverse()
    내림차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.reverse();    

13) function(a,b){return a-b}
    비교함수
    (일반적으로 sort함수 내에 넣어서 사용)

    random 순서로 배열
    ex) 
        const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return 0.5 - Math.random()});
    
    활용 예시)
    <button onclick="myFunction()">Try it</button>
    <p id="demo"></p>

    <script>
        const points = [40, 100, 1, 5, 25, 10];
        document.getElementById("demo").innerHTML = points;  

        function myFunction() {
            points.sort(function(a, b){return 0.5 - Math.random()});
            document.getElementById("demo").innerHTML = points;
        }
    </script>

* JS 자체적으로는 array의 원소들을 자체적으로 비교하려 최대/소 값을 반환하는 max, min함수가 없다.
14-1) max/min 대신에 sort한 뒤에 새롭게 생성된 array에서 첫번째/ 마지막 인덱스를 반환하는 방식으로 최소/최대 값을 구한다.
    ex)
    const points = [40, 100, 1, 5, 25, 10];
    points.sort(function(a, b){return a - b});
    // now points[0] contains the lowest value
    // and points[points.length-1] contains the highest value

    * 이렇게 아니면, for문을 통해 직접 최대/최소 값 반환하는 함수 만들어서 사용

14-2) array의 원소가 숫자인경우(수의 최대/최소 비교)    
    Math.max.aplly(null, 배열명)
    ex)
        function myArrayMax(arr) {
             return Math.max.apply(null, arr);
        }

    Math.min.apply(null, 배열명)
    ex)
        function myArrayMin(arr) {
            return Math.min.apply(null, arr);
        }

array iteration(반복 처리) 
1) forEach()
    기능: array 각각 원소를 한번씩 모두 호출하는 callback함수로 array의 원소들 각각을 반환

    ex1)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value, index, array) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }
    
    ex2)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }

        ex1과 ex2의 결과는 동일

2) map()
    기능: forEach처럼 array의 각 원소들을 index순서로 순회하며 각각의 원소값 모아, array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

    ex2)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

3) array filter()
    기능: array의 원소들 중 특정 조건에 부합하는 원소들만 모아서 array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value) {
        return value > 18;
    }

4) reduce()
    기능: array의 원소들을 index순서대로(오름차순) 순회하며 각각의 값을 순차적으로 삭제, 만약 인자로 입력된 값에 return값이 있는 경우 return값을 반환 
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

    ex3)    :특정 값으로 초기값을 지정할 수 있다.
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction, 100); //초기값을 100으로 지정하고 연산 시작

    function myFunction(total, value) {
        return total + value;
    }

5) every()
    기능: array의 모든 원소들을 index순서(오름차순)로 순회하며 각각의 원소 값이 특정 조건에 만족하는 지 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

6) some()
    기능: array의 원소 중 1개라도 indext순서(오름차순)로 순회하며 확인했을 때, 특정 조건을 만족하는 지 여부를 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value, index, array) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

    ex2)
        const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

7) indexOf()
    기능: array의 원소들 중 입력받읕 특정 값의 index를 반환(숫자로)
    형태: indextOf(찾을 원소값, 검색을 시작할 index번호)

    ex)
    const fruits = ["Apple", "Orange", "Apple", "Mango"];
    let position = fruits.indexOf("Apple") + 1; // index가 0부터 시작이므로 +1을 추가해서 사람이 일반적으로 순서를 셀 때 쓰는 서수 형태 맞추기

8) find()
    * 원소 값을 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개만을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.find(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 25
    // 25와 29 모두 만족하지만, 가장 먼저 조건을 충족하는 원소가 25이므로 25만 반환

9) findIndex()
    * index를 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개의 index값을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 3

10) Array.from()
    기능: 인자로 입력받은 값을 개별 "문자"별로 쪼개어 array를 생성
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

11) keys()
    * array의 key는 index이다.
    기능: array(object)를 구성하는 원소들 중 모든 "key"값만을 순차적으로 순회 및 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const keys = fruits.keys();

    for (let x of keys) {
        text += x + " ";
    }
    // 0 1 2 3 

12) includes()
    기능: array가 특정 원소값을 가지고 있는 지 순차적으로 탐색하여 확인 후 true, false를 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    fruits.includes("Mango"); // is true

* array가 const 변수로 선언되었다는 것이 array의 원소들도 재선언 및 수정이 불가능하다는 의미가 아니다.
* 해당 array가 선언된 const변수를 재선언 할 수 없다는 의미 
즉, const의 조건만 충족하면 된다.(이미 const 변수에 종속되었기 때문)
* 만약 때에 따라 다양한 변형이나 재선언을 시도할 경우 처음부터 array를 var이나 let으로 선언하기

dates

new Date()
    * static 변수로써, 자동으로 업데이트x → 해당 메서드가 선언된 시점의 상태로 지속
    형식: 변수 = new Date()
    
* Date의 다양한 형식은 사용할 때 필요에 따라 검색으로 대체하여 사용 예정 (깊게 공부x)

math(수학 함수들)

1) Math.round()
    입력받은 인자를 반올림

2) Math.ceil()
    입력받은 인자를 올림

3) Math.floor()
    입력받은 인자를 내림

4) Math.trunc()
    입력받은 인자에서 "정수"부분만 추출하여 반환

5) Math.pow()
    형식: Math.pow(인자1, 인자2)
    기능: 인자1^인자2의 값을 반환   *거듭제곱(power)의 약자

6) Math.sqrt()
    입력받은 인자의 제곱근을 반환   *squaroot의 약자

7) Math.abs()
    입력받은 인자의 절대값을 반환   *absolute의 약자

8) Math.max() / Math.min()
    입력받은 인자의 최대, 최소 값 반환

9) Math.random()
    0~1까지의 값 중 랜덤으로 값을 반환(소수형태로 반환)

random
    random 함수의 특성활용해서 필요에 맞게 가공하기
    random함수는 0~1까지의 수를 반환

    ex)
        Math.floor(Math.random()*10)    //1자리 정수의 값으로 반환(즉 0~9까지의 수가 랜덤으로 반환)
        Math.floor(Math.random()*10)+1  //1자리 정수+10까지의 값으로 반환(즉 1~10까지의 수가 랜덤으로 반환)

Boolean
    타 언어의 boolean함수와 동일

comparison operations
* JS는 독특한 비교연산자가 존재!
* 별다른 이유가 없다면 JS마스터가 아니고서는 "===" 비교연산자 사용하기(예상하지 못한 error를 사전에 방지가능)

    * x = 5라고 값이 지정된 경우,
    Operator	Description	                        Comparing	Returns	
    ==	        값 동일	                             x == 8	    false	
                                                    x == 5	    true	
                                                    x == "5"	true	
    ===	        값 동일, 데이터 형식 동일   	     x === 5	  true	
                                                    x === "5"	false	
    !=	        값이 다른 경우 	                     x != 8	    true	
    !==	        값이 다르거나, 데이터형식이 다른 경우 x !== 5	    false	
                                                    x !== "5"	true	
                                                    x !== 8	    true	
    >	        크다        	                    x > 8	    false	
    <	        작다       	                        x < 8	    true	
    >=	        크거나 같다             	        x >= 8	    false	
    <=	        작거나 같다         	            x <= 8	    true

logical operations

    * x=6, y=3이 선언되었을 때,
    Operator	Description	        Example	
    &&	        and	                (x < 10 && y > 1) is true	
    ||	        or	                (x == 5 || y == 5) is false	
    !	        not	                !(x == y) is true

lambda operations
    형식: 변수 = (조건) ? 값1 : 값2
        * 조건이 true이면 값1을, false면 값2를 반환

conditions(조건문)
    Java의 조건문과 동일
    if/     else if     /else

switch(스위치문)
    Java의 스위치문과 동일
    * case의 값으로는 "숫자"만 가능!
    
    형식:
        switch(expression) {
            case x:                 //x인 경우
                // code block
                break;
            case y:                 //y인 경우
                // code block
                break;
            default:                // 기본값(일치 값이 없는 경우)
                // code block
        }

for (for문)
    for문 자체의 사용방법: java의 for문과 동일

for in
    for 문 내부의 애트리뷰트로 in을 사용

    1) 배열에 for in 사용 → index number을 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 number를 반환)
            result += object[key];
        }

    2) 객체(object)에 for in 사용 → key를 반환
    ex)
        const object = [first: "a", second: "b", third: "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 key를 반환)
            result += object[key];
        }

for of
    for 문 내부의 애트리뷰트로 of를 사용    

    배열의 값을 반환(index number이 아닌, value를 반환)
    객체 역시 value를 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key of object){         // python의 in 과 동일한 역할 수행(배열 내 각 원소들를 반환)
            result += key;
        }

while
    Java의 while문과 동일한 문법

do while    :while과 동일한 역할을 하지만, 조건이 충족되기 전에 먼저 실행부터 하고 조건을 확인한 뒤 이후의 연산을 결정
    ex)
        do{
            ...
        }
        while{
            ...
        }

분기문
break       :해당 반복을 종료           //java, python의  break와 동일
continue    :아래의 코드를 무시하고 다음 반복을 실행    //java의 continue, python의 pass와 동일

iterables
    1) String
    2) Array / Object 

    * 위의 두가지 자료형이 반복이 가능한 자료형(반복문 사용가능 )

set
    개념: '집합' 자료형
    * set 내에는 중복되는 원소가 존재할 수 없다.(집합의 정의에 의해)
    * set의 원소로 동일한 원소가 중복으로 입력되면 무시한다.

    Method	        Description
    new Set()	    새로운 집합(비어있는 집합)을 생성
    add()	        원소를 가장 마지막에 추가
    delete()    	인자로 입력받은 원소 삭제(index가 아니라, element를 인자로 입력해야 한다.)
    has()       	인자로 입력받은 원소가 set 안에 있으면 true, 없으면 false반환
    forEach()   	set이 원소로 가지고 있는 모든 원소들을 좌→우 순서로 순회하며 callback(반환)한다.
        ex)
            const letters = new Set(["a","b","c"]);

            let text = "";
            letters.forEach (function(value) {
                text += value;
            })

    values()    	set의 모든 원소를 반환
        ex)

            let text = "";
            for (const x of letters.values()) {
                text += x;
            }
    
maps
    object처럼 dictionary자료형 역할을 할 수 있는 자료형
    개별 [key: value] 쌍으로 구성
    형식:
        ex) 직접선언
        const fruits = new Map([
            ["apples", 500],
            ["bananas", 300],
            ["oranges", 200]
        ]);

        ex) 이후 추가
        const fruits = new Map();

        fruits.set("apples", 500);
        fruits.set("bananas", 300);
        fruits.set("oranges", 200);

    메서드 종류
        Method	        Description
        new Map()	    map 생성
        set()	        map의 key값과 value값 생성
        get()	        map의 특정 key값과 value값을 가져와서 반환
        delete()	    특정 key값을 입력받아, 해당하는 원소를 map에서 제거(key와 value 동시에 제거)
        has()	        특정 key값을 입력받아, 해당하는 원소가 map에 존재하는 지 여부 확인 후 true/false 반환
        forEach()	    map의 각 원소들을 반환(이때, key와 value 모두 각 원소들을 순회하며 반환) → 세부적으로 key, value 중 필요한 값을 선택 가능
        entries()	    각 원소들을 순회하며 key와 value 모두 동시에 반환

        Property	    Description
        size	        map의 원소 수를 반환
    

* objects vs maps
    
    	            Object	                            Map
        Iterable	Not directly iterable	            Directly iterable
        Size	    Do not have a size property	        Have a size property
        Key Types	Keys must be Strings (or Symbols)	Keys can be any datatype
        Key Order	Keys are not well ordered	        Keys are ordered by insertion
        Defaults	Have default keys	                Do not have default keys

typeOf
    1) 값을 담을 수 있는 자료형:
        string
        number
        boolean
        object
        function
    
    2) 객체인 자료형:
        Object
        Date
        Array
        String
        Number
        Boolean
    
    3) 값을 가질 수 없는 자료형:
        null
        undefined


error
    try         :시도해볼 코드
    catch       :error을 만났을 때 대처할 코드
    finally     :결과에 상관없이 코드를 실행
    throw       :개발자가 의도된 에러를 만들 때 실행

    형식:
        try{
            시도할 코드
        }
        catch(err){
            에러에 대처할 코드
        }
    
    throw 사용법:
    * String,   Number, Boolean, Object형태로 선언가능
        throw "Too Big.";
        throw 500;
    ex)
        <html>
        <body>

            <h2>JavaScript try catch</h2>

            <p>Please input a number between 5 and 10:</p>

            <input id="root" type="text">
            <button type="button" onclick="myFunction()">Test Input</button>
            <p id="p01"></p>

            <script>
                function myFunction() {
                    const message = document.getElementById("p01");
                    message.innerHTML = "";
                    let x = document.getElementById("root").value;
                    try { 
                        if(x == "")  throw "empty";         //상황에 맞게 custom error를 정의
                        if(isNaN(x)) throw "not a number";
                        x = Number(x);
                        if(x < 5)  throw "too low";
                        if(x > 10)   throw "too high";
                    }
                    catch(err) {
                        message.innerHTML = "Input is " + err;  //해당 error를 html로 보내서 출력
                    }
                    finally{
                        document.getElementById("root").value="";   //error 유무에 상관없이 실행할 코드 정의(조회수 기록, 연산 등 수행 목적으로 쓰일 것으로 보임)
                    }
                }
            </script>

        </body>
        </html>

block Scope
    let변수는 { } 밖에서 사용 불가능
    var변수는 { } 밖에서 사용 가능

    function 내에 선언된 모든 변수는 function 내에서만 사용 가능  
    ex)
        function myFunction(){
            let pizzaName = "Cheese";
        }   //함수 밖에서 pizzaName 변수 사용 불가능


hoisting

    1) var  
    * var변수에 한하여 hoisting가능하다
    특징: 변수들이 선언되기 전에 사용될 수 있다.
    * 변수를 우선 사용한 뒤, 선언가능
    ex) 
        // 선언 전에 변수를 선제 사용
        x = 5;  
        elements = document.getElementById("root");
        element.innerHTML = x;
        // 변수의 후 선언
        var x;

    * 단 var이 hoisting 될 때에는 var에 값이 지정된 상태일 때만 가능하다.

    2) let, const
    * let과 const 두 변수들은 hoisting 사용이 불가능하다.

strict mode
    *JS의 자유로움으로 인하여 예상치 못한 error가 발생하는 것을 방지하기 위한 방법
    ex)
        "use strict";
        myFunction();

        function myFunction() {
            y = 3.14;   // strict mode로 인해 선언되지 않은 변수y는 hoisting을 허용하지 않는다.(타 언어들처럼 엄격한 규칙을 가지게 된다.)
        }
    

    strict mode에서 허용하지 않는 것:
        1) hoisting
        2) 변수/객체/함수의 삭제  delete 명령어
        3) 중복된 변수의 사용
        4) 0이 첫번째 자리로 오는 숫자
        5) escape charactors
        등..
        더 많은 내용은 링크 참고 (https://www.w3schools.com/js/js_strict.asp)
    
arrow function
    함수 선언의 축약형
    
    사용법의 차이
    ex) 일반적 함수 선언
        hello = function() {
            return "Hello World.";
        }
    ex) arrow function
        hello = () =>{
            return "Hello World.";
        }
    
    this 메서드의 인식 차이
    ex) 일반적 함수 선언
        hello = function() {
            document.getElementById("root").innerHTML += this;      //this는 함수를 담은 외부의 객체를 지칭
        }
    
    ex) arrow function
        hello = () => {
            document.getElementById("root").innerHTML += this;      //this는 함수를 가지고 있는 객체를 지칭
        }

class
    형식:
        class ClassName{        //함수 선언
            constructor(){      //생성자 선언
                ...
            }
        }
    
    ex)
        class Car {
            constructor(name, year) {   //입력받은 인자인 name과 year을 지칭
                this.name = name;
                this.year = year;
            }
        }
    
    1) constructor
    * 생성자는 반드시 constructor라는 정확한 이름으로 기재해야 한다.
    * 생성자는 객체가 생성되면 자동으로 실행
    * 객체(함수)에 모두 적용된다. → 함수에 사용될 class 내부의 전역 변수로서 개별 함수에서는 "인자(parameter)"로 쓰일 수 있다.
    선언 형식:
        class ClassName {
            constructor() { ... }   //생성자는 1개 가장 상위에 위치
            method_1() { ... }      //class의 개별 메소드들(클래스 소속 함수)
            method_2() { ... }
            method_3() { ... }
        }

    ex)
        class Car {
            constructor(name, year) {
                this.name = name;
                this.year = year;
            }
            age() {
                let date = new Date();
                return date.getFullYear() - this.year;
            }
        }

        let myCar = new Car("Ford", 2014);
        document.getElementById("demo").innerHTML =
        "My car is " + myCar.age() + " years old.";
    
JSON
    Java Script Object Notation
    특징:
        1) 가벼운 데이터에 대한 변환 포멧 존재
        2) 독립적인 언어
        3) 자기기술성이 있으며, 이해하기 쉬운 편
    
    JS의 프로그램이 JSON 데이터로 쉽게 변형될 수 있다.

    기본 형식:
        1) data는 이름/값(name/value)쌍이 맞아야 한다.
        2) data는 ,로 구분된다.
        3) 중괄호가 객체를 감싼다.
        4) 대괄호가 전체 배열을 감싼다.
    ex)
        "employees":[
            {"firstName":"John", "lastName":"Doe"},
            {"firstName":"Anna", "lastName":"Smith"},
            {"firstName":"Peter", "lastName":"Jones"}
        ]
    
    JSON을 JS로 변환하기
    1) 일반 객체를 활용해서 text 내의 employee라는 배열로 만들기
        ex)
            let text = '{ "employees" : [' +
                '{ "firstName":"John" , "lastName":"Doe" },' +
                '{ "firstName":"Anna" , "lastName":"Smith" },' +
                '{ "firstName":"Peter" , "lastName":"Jones" } ]
            }';
    
    2) JSON.parse를 활용해서 데이터의 형태를 string으로 바꾸기
        ex)
            const obj = JSON.parse(text);
    
     → obj.employee[1].firstname 을 호출하면 "Anna"가 반환된다.
     만약 JSON.parse로 JSON의 데이터를 담은 JS변수를 string으로 변환하지 않으면 정상적으로 출력이 안된다.
     (text.employee[1].firstname을 호출하면 아무런 결과도 반환되지 않는다.)

debugging
    1) console.log() 사용
        JS의 코드를 web browser을 통해 보여준다.
    
    2) debugger; 키워드
        debugg할 때 breakpoint를 지정
        
        ex)
            let x = 15 * 5;
            debugger;
            document.getElementById("demo").innerHTML = x;

JS 코드 짜는 Tip:
    1) 코드를 짤 때 new, ==, eval()을 가급적 사용x
    2) 변수를 가장 위에 한번에 명시하는 연습
    3) 변수를 선언할 때 반드시 "초기화"하는 연습
    4) 가능하면 변수를 const로 선언하며 데이터 형태가 의도치 않게 변형되는 것을 방지
    5) 배열 선언 시 데이터형을 const로 선언하여 데이터 형태가 의도치 않게 변형되는 것을 방지
    6) new 객체() 선언x → 속도가 느려질 수 있다.
    7) == 대신에 데이터형까지도 체크하는 ===을 사용
    8) 함수에 defualt parameter 부여하기
        ex)
            function (a=1, b=1) { /*function code*/ }
    9)switch문의 마지막은 반드시 default값으로 넣기
    10) Number, String, Boolean을 new 객체이름() 형식으로 선언해서 "객체화"하지 않기
        ex)
            let x = "John";             
            let y = new String("John");
            (x === y) // is false because x is a string and y is an object.
    
    11) 반복문 안에서 메서드 사용x, 외부에서 연산하여 반복문에서는 상수 위주로 사용하기 (속도 향상을 위해)
        ex)
            let l = arr.length;
            for (let i = 0; i < l; i++) {   // i<arr.length를 반복문 구문 내에 호출하면 매 루프 때마다 length를 계산해야 하는 중복연산이 발생
            }

    12) DOM 접근을 최소화하기  
        * DOM은 JS의 속도를 느리게 만드는 요인 중 하나
        * 따라서 DOM을 사용할 때에도 DOM의 내부 코드를 최소화하기(DOM 활용 시 코드의 간소화 필요)

        bad ex)
            let fullName = firstName + " " + lastName;
            document.getElementById("demo").innerHTML = fullName;
        
        good ex)
            document.getElementById("demo").innerHTML = firstName + " " + lastName;
    

#JS Advance
JS callbacks
    콜백 사용 이유:
        특정 기능을 선수행한 뒤, 결과값을 반환하는 것이 필요한 경우
    
    * 재귀함수와 유사한 개념으로, 재귀함수가 특정 조건 만족 시까지 연산을 반복수행하는 것과 달리, callback은 재귀연산을 1번만 수행한다.
    함수1 내에 인자로써 함수2를 입력하는 경우에 사용된다.
    이때 함수1의 인자 중 callback할 수 있는 인자의 자리에 함수2가 입력된다.
    함수1의 실행결과 callback용 변수의 인자로 실행결과를 담으면 함수2의 인자로 함수1의 실행결과가 담긴 형태가 된다. 
    
    ex)
        <html>
        <body>

            <h2>JavaScript Callbacks</h2>

            <p>Do a calculation and then display the result.</p>

            <p id="demo"></p>

            <script>
                function myDisplayer(something) {
                    document.getElementById("demo").innerHTML = something;
                }

                function myCalculator(num1, num2, myCallback) {     //인자로 myCallback을 입력
                    let sum = num1 + num2;
                    myCallback(sum);        //함수의 실행결과로써 myCallback에 변수(값)를 담아 반환
                                            //myCalculator의 myCallback인자로 myDisplayer라는 함수가 입력되었기에, 
                                            //myCalculator함수의 실행 결과에 따른 myCallback의 인자로 sum이 입력된 것은 myDisplayer의 something인자로 sum이 입력된 것을 의미.
                }

                myCalculator(5, 5, myDisplayer); //myCalculator의 인자로 함수인 myDisplayer가 입력
            </script>

        </body>
    </html>
    
asynchronous JS
    현업에서 callback을 활용할 때, 여러 메서드와 함께 사용하여 callback될 시간을 정할 수 있다.
    
    1) setTimeout()
    ex)
        <html>
        <body>
            <h2>JavaScript Callback</h2>
            <p>Wait 3 seconds (3000 milliseconds) for this page to change.</p>

            <h1d="demo"></h1>

            <script>
                setTimeout(myFunction, 3000);       //setTimeout(대상, 초설정)  :설정한 초 뒤에 대상을 실행 (1회 실행)
                                                    //일반적으로 "대상"으로 함수를 입력
                function myFunction() {
                    document.getElementById("demo").innerHTML = "I love You !!";
                }
            </script>
        </body>
        </html>

    2) setInterval()
    ex)
        <html>
        <body>

            <h2>JavaScript setInterval()</h2>

            <p>Using setInterval() to display the time every second (1000 milliseconds).</p>

            <h1 id="demo"></h1>

            <script>
                setInterval(myFunction, 1000);      //setInterval(대상, 초설정) :설정한 초 간격으로 대상을 실행(지속적으로 실행)

                function myFunction() {
                    let d = new Date();
                    document.getElementById("demo").innerHTML=
                    d.getHours() + ":" +
                    d.getMinutes() + ":" +
                    d.getSeconds();
                }
            </script>

        </body>
        </html>
    
    3) 특정 파일이 loading될 때까지 기다리기
        XMLHttpRequest() 객체를 활용
            메서드:
                open(데이터형식, 대상)
                onload
                status
                responeText
                send()
        ex)
            <html>
            <body>
                <h2>JavaScript Callbacks</h2>
                <p id="demo"></p>

                <script>
                    function myDisplayer(some) {
                        document.getElementById("demo").innerHTML = some;
                    }

                    function getFile(myCallback) {
                        let req = new XMLHttpRequest();
                        req.open('GET', "mycar.html");
                        req.onload = function() {
                            if (req.status == 200) {
                                myCallback(this.responseText);
                            } 
                            else {
                                myCallback("Error: " + req.status);
                            }
                        }
                        req.send();
                    }

                    getFile(myDisplayer); 
                </script>
            </body>
            </html>
    
HTML DOM 
    Document Object model
    DOM은 W3C(World Wide Web Consortium)의 표준으로, 언어중심 인터페이스로 프로그램과 script가 동적으로 접속하고 콘텐츠와 구조, 스타일을 최신화하는 것을 지원

    3가지 부분:
        1) Core DOM :모든 문서 형식에 대한 모델
        2) XML DOM  :XML 문서에 대한 모델
        3) HTML DOM :HTML문서에 대한 모델
    
    DOM Method: 동작
    DOM Value:  값(setting이나 변경 가능)

    ex)
        <html>
        <body>
            <p id="demo"></p>
            <script>
                document.getElementById("demo").innerHTML = "Hello World!";     // getElementById는 method이고, innerHTML은 property이다.
            </script>
        </body>
        </html>
    
    getElementById()    :HTML의 tag 속 id를 기준으로 해당 Element를 호출하여 script로 활용할 수 있는 메서드
    innerHTML           :HTML element를 가져오고 변경할 수 있는 property(* property: method 내에 있는 멤버의 기능 수행)

DOM Documents
    1) HTML Element를 찾는 메서드:

        Method	                                Description
        document.getElementById(id)	            Find an element by element id
        document.getElementsByTagName(name)	    Find elements by tag name
        document.getElementsByClassName(name)	Find elements by class name

        * 모두 id, name을 입력할 때 "내용물" 형태로 입력 
            html 태그들도 <> 는 모두 없애고 <> 대신에 ""로 입력한다.

        querySelectorAll() :
            CSS selectors가 정해진 특정 값을 탐색할 경우

            ex)
                const x = document.querySelectorAll("p.intro");         //document의 메서드로 querySelectorAll("CSS Selector이름")
                


    2) HTML Element를 바꾸는 property/메서드:
        Property	                                Description
        element.innerHTML =  new html content	    Change the inner HTML of an element
        element.attribute = new value	            Change the attribute value of an HTML element
        element.style.property = new style	        Change the style of an HTML element

        Method	                                    Description
        element.setAttribute(attribute, value)	    Change the attribute value of an HTML element  
        * element.attribute 와 동일한 기능을 수행
    
    3) HTML Element를 추가하고 삭제하는 메서드:

        Method	                                Description
        document.createElement(element)	        Create an HTML element
        document.removeChild(element)	        Remove an HTML element
        document.appendChild(element)	        Add an HTML element
        document.replaceChild(new, old)	        Replace an HTML element
        document.write(text)	                Write into the HTML output stream
    
    4) Event hendler 메서드:
        * HTML Element를 클릭했을 때의 동작을 정의

        Method	                                                    Description
        document.getElementById(id).onclick = function(){code}	    Adding event handler code to an onclick event
    
    5) HTML Object에 대한 값을 JS로 반환하는 properties:

        Property	                    Description
        document.anchors	            Returns all <a> elements that have a name attribute	
        document.applets	            Deprecated	
        document.baseURI	            Returns the absolute base URI of the document	
        document.body	                Returns the <body> element	
        document.cookie	                Returns the document's cookie	
        document.doctype	            Returns the document's doctype	
        document.documentElement	    Returns the <html> element	
        document.documentMode	        Returns the mode used by the browser	
        document.documentURI	        Returns the URI of the document	
        document.domain	                Returns the domain name of the document server	
        document.domConfig	            Obsolete.	
        document.embeds	                Returns all <embed> elements	
        document.forms	                Returns all <form> elements	
        document.head	                Returns the <head> elements
        document.images	                Returns all <img> elements	
        document.implementation	        Returns the DOM implementation	
        document.inputEncoding	        Returns the document's encoding (character set)	
        document.lastModified	        Returns the date and time the document was updated	
        document.links	                Returns all <area> and <a> elements that have a href attribute	
        document.readyState	            Returns the (loading) status of the document	
        document.referrer	            Returns the URI of the referrer (the linking document)	
        document.scripts	            Returns all <script> elements	
        document.strictErrorChecking	Returns if error checking is enforced	
        document.title	                Returns the <title> element	
        document.URL	                Returns the complete URL of the document	

