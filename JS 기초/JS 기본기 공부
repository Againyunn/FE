JS 기본적인 활용

JS는 html과 연결될 때, class 단위가 아니라, 특정 HTML element에 적용할 때 주로 "getElementById("아이디 명")"의 형태로 "id"기준으로 HTML element를 호출한다.
그러므로, head / body 어디에 JS코드가 위치하든 <script>  </script> 태그 사이에 코드들을 정의하고 getElementById("아이디 명")으로 HTML element와 연결한다.

output
- display할 수 있는 방법:
    1) innerHTML        :HTML 엘리먼트 안에 특정 내용을 JS 코드로 직접 입력
    2) document.write() :해당 코드가 위치한 곳에 JS 코드로 직접 입력 → <script> 가 body에 선언되었을 때도 사용할 수 있으며, 여러 HTML tag에 이어서 JS코드가 선언된 위치에 값을 바로 반환
        * HTML 엘리먼트가 생성 된 후 document.write()을 사용하면 생성된 HTML 의 모든 엘리먼트가 삭제되고 JS코드로 작성한 내용만 표기된다.(ex : onclick 메서드와 같은 애트리뷰트 이용 시)

    3) window.alert()   :브라우져의 "알림창"으로 JS코드로 입력된 값을 반환
    4) console.log()    :브라우져의 "콘솔 창"으로 JS코드로 입력된 값을 반환

* JS는 python, java, C등과 다르게 자체적인 "print()"메서드가 없다.
    window.print() 는 웹 페이지를 인쇄한다는 명령어

JS 주요 제어자
    Keyword	    Description
    var	        변수 재선언 가능, 재할당 가능(orriding 가능)
    let	        변수 재선언 불가, 재할당 가능(orriding 가능)
    const	    변수 재선언 불가, 재할당 불가능
    if	        조건문
    switch	    switch문
    for	        반복문
    function	함수 정의
    return	    함수 종료 및 반환 값
    try	        예외처리 블럭

variables
* 블럭 선언 불가능
재선언 가능
    ex) var x = 5; var x = 6; 

재할당 가능
    ex) var x = 0; x =5;

let
* 블럭으로 선언가능 {} 사용가능
재선언 불가능  
    ex) let x = 6; let x = 7;      //Syntax error 발생

재할당 가능
    ex) let x = 0; x = 5;       

const
* 블럭으로 선언가능 {} 사용가능
재선언 불가능
재할당 불가능 
* 처음 선언할 때의 형태 그대로만 사용가능

연산자 및 증감자는 JAvA와 동일(축약 연산자도 동일)

data types
python처럼 변수의 데이터형을 프로그램이 알아서 해석

주요 특징:
    1) 타 언어와 마찬가지로, 숫자+String(문자/문자열) = 모두 문자열로 바꾸어 연산한다.
    2) 연산에 순서가 존재(동일한 내용이더라도 순서가 다르면 결과가 달라질 수 있다.)
        ex) 
            경우1: let x = 16 + 4 + "Hello"     //"20Hello"
            경우2: let x = "Hello" + 16 + 4     //"Hello164"
        
function
1) 함수 자체로 선언하기
    function myWorld(a, b){
        ...
        return 
    }
2) 변수에 함수 생성
    const myWorld=(a, b) => {
        ...
        return
    }

object(객체)
* 일반적으로 "객체" 선언 시에는 const를 사용한다.

* 객체 내의 여러 값들을 지정할 경우 python의 dictionary와 유사하게 선언(python → car = {type: "Fiat", model: "500", color: "white"})
자료형 변수명 = {name1:"value1", name2:"value2"...}
ex) 
    const car = {type: "Fiat", model: "500", color: "white"};

accessing object properties에 접근하는 방법
방법1:
    objectName.propertyName

방법2:
    objectName["propertyName"]

* 타 언어와 다른 점은 "객체(상수, 변수)"에 "함수"를 담을 수 있다는 점
ex) 
    cosnt oneMan={
        firstName: "John",
        lastName: "Joe",
        id: 0523;
        fullName : fuction(){
            return this.firstName + " " + this.lastName;    // this를 통해서 해당 객체 내부에 선언된 변수를 재귀대명사처럼 지칭가능(Java의 this와 동일)
        }
    }

accessing object methods
방법:
    objectName.methodName()         //타 언어와 동일

* 주의:
    String, Number, Boolean 등의 객체의 데이터형을 변수에 선언하기x → 프로그램의 실행속도가 늦어지게 만들 수 있다.
    ex) x = new String(); // 이런식으로 선언x


HTML event 사용하기
HTML tag 내부에서 사용:
    <element event = "JS 코드"> 형식으로 사용

자주사용하는 HTML events
    Event	            Description
    onchange	        html 엘리먼트가 바뀌었을 때
    onclick	            html 엘리먼트를 클릭했을 때
    onmouseover	        html 엘리먼트에 마우스를 올렸을 때
    onmouseout	        html 엘리먼트에 마우스를 댔다가 떼었을 때
    onkeydown	        사용자가 키보드 자판을 눌렀을 때
    onload	            브라우져가 로딩을 다 끝냈을 때(페이지 생성을 다 끝냈을 때)

string
""와 ''를 모두 사용가능
    ex) let a = "It's a apple.";

길이 메서드
    string객체.length       //Java와 동일

인용문자 표기
    Code	Result	Description
    \'	    '	    Single quote
    \"	    "	    Double quote
    \\	    \	    Backslash

escape sequences
* html에서는 사용x, 주로 백그라운드 프로그램의 연산, 함수에 이용
    Code	Result
    \b	    Backspace
    \f  	Form Feed
    \n	    New Line
    \r	    Carriage Return
    \t	    Horizontal Tabulator
    \v	    Vertical Tabulator

string methods
1) extracting string parts(string의 일부를 추출)
    slice(start, end)
        시작~ 끝까지의 "문자열 index"를 입력
    
    substring(start, end)
        시작~ 끝까지의 "문자"를 입력(부문자열 입력)

    substr(start, length)
        시작의 indext와 길이(index길이)를 입력
    
2) replacing string content(string를 수정)
    string문자열.replace("변경의 대상", "변경할 대상")
    * replace 메서드는 해당 string의 원형을 변경하지 않는다. 변경된 것을 반환만 한다. 그러므로 반환된 객체를 받을 변수가 필요하다.
    * 소문자/대문자의 형태로 동일하게 맞춰야 한다.
    ex)
        let text = "We'll take yellow";
        let newText = text.replace("yellow", "skyblue")
    * 정규식을 통해 조건을 구체화할 수 있다.
    ex) 
        let text = "We'll take yellow!";
        let newText = text.replace("/yellow/g", "skyblue")  // /ge  : 뒤에 문자가 더 있는 경우로 제한

3) 대/소문자 변경
    toUpperCase()   :대문자로 변경
    toLowerCase()   :소문자로 변경

4) 공백 없애기
    trim()      :해당 string 내부의 공백을 없앤다

5) extracting string charactors(문자만을 추출)  
    charAt(indexNum)
        해당 인덱스에 해당하는 문자를 반환 

    charCodeAt(indexNum)
        해당 인덱스에 해당하는 문자의 unicode를 반환

6) string split(문자열을 구분하여 배열로 저장)  
    문자열.split("구분할 방식")
        ex)
            let nums= "0, 1, 2, 3, 4, 5";
            const numsArray= nums.split(", ");
            console.log(numsArray[1]);          // 1 반환           
    
        ex)
            let hello="Hello";
            const helloArray= hello.split("");
            console.log(helloArray[1]);          // e 반환

string search
1) indextOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 첫번째 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)
    ex)     
        let str = "Please locate where 'locate' occurs!";
        str.indexOf("locate");

2) lastIndexOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 마지막 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)

3) search()
    indexOf와 거의 동일한 역할 수행

4) match()
    입력받은 문자와 동일한 문자가 해당 문자에 있는 지 확인하고 존재하면 입력받은 문자들 배열의 형태로 반환
    ex) 
        let text = "The rain in SPAIN stays mainly in plain.";
        text.match(/ain/g);         // ain,ain,ain

5) includes()
    입력받은 문자가 해당 문자에 존재하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.includes("world");             // true

6) startsWith()
    입력받은 문자로 해당 문자열이 시작하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.startsWith("Hello");           // true

7) endsWith()
    입력받은 문자로 해당 문자열로 끝는 지 여부를 판별(true / false)
    ex)
        var text = "John Doe";
        text.endsWith("Doe");               // true

template literals
    표현식:
        ` 문자(열) ` 
    활용:
        1) 문자열 "" 나 '' 대신 사용 가능
        2) 문자열 내부에 "" 나 ''를 제약 없이 사용가능
        3) 문자열이지만, 줄 바꿈을 허용
        4) 변수의 format 서식자 사용가능
            ex)
                let firstName = "John";
                let lastName = "Doe";   
                let text = `Welcome ${firstName}, ${lastName}!`;
        5) 문자열 내부의 변수간 연산을 허용
            ex)
                let price = 10;
                let VAT = 0.25;
                let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;
        6) HTML tag(element)도 직접 사용가능
            ex)
                let header = "Templates Literals";
                let tags = ["template literals", "javascript", "es6"];

                let html = `<h2>${header}</h2><ul>`;
                for (const x of tags) {

                html += `<li>${x}</li>`;
                }

                html += `</ul>`;

number
* number와 string 간 덧셈 연산을 해도, 이를 string간의 연산으로 간주한다.
ex) let x = "10";
    let y = 20;
    let z = x + y; // 1020

* 그 외의 연산은 string을 number로 compile한 뒤 연산한다.

무한    :infinity

number methods
1) toString()
    숫자를 문자로 전환
    ex) let x = 523;
        x.toString();

    ex) (123).toString();
        (100 + 23).toSting();

2) toFixed()
    소수점 자리를 고정
    ex) let x = 9.656;
        x.toFixed(0);   //9
        x.toFixed(2);   //9.65
        x.tofixed(4);   //9.6560

3) toExponential()
    소수점 특정 자리에서 "반올림"
    ex) let x = 9.656;
        x.toExponential(0);   //9
        x.toExponential(2);   //9.65
        x.toExponential(4);   //9.6560

4) Number()
    객체를 "수"로 변환

5) parseFloat()
    객체를 실수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

6) parseInt()
    객체를 정수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

7) max()
    입력받은 숫자 중 가장 큰 수를 반환

8) min()
    입력받은 숫자 중 가장 작은 수를 반환

array
* 배열은 주로 const를 활용한다.
    ex)
        const color = ["white", "green", "yellow"];

그 외의 기본적인 array관련 문법은 타 언어와 동일

HTML tag 내부에 자동으로 ,를 생성하여 출력된다.
ex)
    const color = ["white", "green", "yellow"];
    document.getElementById("root").innerHTML = color;  //white, green, yellow

배열 내의 원소(index) 간 datatype이 달라도 된다.
    ex)
        const person = ["John", "Lucas" , 26];  // 이렇게 넣어도 오류 발생x

array 내부에 object(객체)를 넣을 수 있다.
    1) 객체+메서드 넣기
        ex) myArray[0] = Date.now;
    
    2) 함수 넣기
        ex) myArray[1] = myFunction;    //function 함수 넣기
    
    3) 객체 넣기
        ex) myArray[2] = myCars;    //object 객체 넣기

array(배열) vs object(객체)
    * 둘의 가장 큰 차이: 호출 방식이 배열은 "number index", 객체는 "named index"
    array:    const person = ["John", "Lucas" , 26];
    호출방법:   cosnt result = person[0];   //John

    object:   const person = {firstName: "John", nickName: "Lucas", age: 26};   //python 의 dictionary와 유사
    호출방법:   const result = person.firstName;    //John

adding array elements
    const fruits = ["Banana", "Orange" ,"Apple"];
    fruits.push("Lemon");   // stack이나 queue처럼 push를 통해 새로운 원소가 배열의 맨 끝에 추가된다.

* JS가 인식하는 array의 타입
    typeOf 메서드 활용 →  object로 반환한다.


array method
1) toString()
    배열의 원소들을 모아, 문자열로 반환(각 원소 사이에 ,를 자동삽입)

    ex)
        const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.toString();      //Banana,Orange
        // toString메서드 내부에 넣지 않고, 객체의 메서드로 적용(인자 넣지x)
    
2) join()
    배열의 원소들을 모아, 각 인덱스별로 특정 문자를 넣어 문자열로 반환
    
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.join(" * ");      //Banana * Orange
        // python의 join과 동일한 역할 수행

3) pop()
    배열의 가장 마지막 원소를 삭제 후 반환(pop의 내부 인자로 값을 넣어도, 해당 배열의 마지막 원소만을 삭제 후 반환)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.pop(); 

4) push()
    배열의 가장 마지막 원소로 새로운 원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.push("Mango");

5) shift()
    배열의 가장 첫번째 원소를 삭제하고 모든 원소들의 index를 하나씩 당기고, 재조합된(첫번째 원소가 삭제된)배열을 반환(삭제된 배열의 index를 빈값으로 유지x)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.shift();     //Orange

6) unshift()
    배열의 첫번째 인덱스에 특정원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.unshift("Mango");     //Mango,Banana,Orange

7) length
    배열의 원소 수를 반환
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.length; //2

8) concat()
    배열끼리의 병합
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        cosnt myChildren = myGirls.concat(myBoys);  //Cecile,Lone,Emil,Tom
    
    * 여러 개의 배열을 한번에 병합도 가능하다.
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        const myPuppy = ["guembee"]
        cosnt myChildren = myGirls.concat(myBoys, myPuppy);  //Cecile,Lone,Emil,Tom,guembee

9) splice()
    형식:   splice(추가할 인덱스 위치, 삭제할 원소 수, 추가할 원자들1, 추가할 원자들2 ...)
    * 원본 array의 원소에 영향을 미친다.
    
    특정 위치에 원소 삽입
    ex) 
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 0, "Lemon", "Kiwi");   //Banana,Orange,Lemon,Kiwi,Apple,Mango

    특정 위치의 원소 삭제
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 2, "Lemon", "Kiwi");   //Orange,Apple,Mango
    
10) slice
    * 원본 array에 영향x, 새롭게 변경된 array를 생성하여 반환
    * 자를 위치의 인덱스 앞까지의 원소들을 새로운 array로 생성하여 반환
    형식:   slice(자를 인덱스 번호)

    ex)
        const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
        const citrus = fruits.slice(1); //Banana
        //  원본 배열인 fruits는 그대로 존재, 새롭게 생성된 배열 citrus만 생성

11) sort()
    오름차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.sort();      //Apple,Banana,Mango,Orange

    숫자의 오름차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return a - b});  // 1,5,10,25,40,100
    
    숫자의 내림차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return b - a});  // 100,40,25,10,5,1

12) reverse()
    내림차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.reverse();    

13) function(a,b){return a-b}
    비교함수
    (일반적으로 sort함수 내에 넣어서 사용)

    random 순서로 배열
    ex) 
        const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return 0.5 - Math.random()});
    
    활용 예시)
    <button onclick="myFunction()">Try it</button>
    <p id="demo"></p>

    <script>
        const points = [40, 100, 1, 5, 25, 10];
        document.getElementById("demo").innerHTML = points;  

        function myFunction() {
            points.sort(function(a, b){return 0.5 - Math.random()});
            document.getElementById("demo").innerHTML = points;
        }
    </script>

* JS 자체적으로는 array의 원소들을 자체적으로 비교하려 최대/소 값을 반환하는 max, min함수가 없다.
14-1) max/min 대신에 sort한 뒤에 새롭게 생성된 array에서 첫번째/ 마지막 인덱스를 반환하는 방식으로 최소/최대 값을 구한다.
    ex)
    const points = [40, 100, 1, 5, 25, 10];
    points.sort(function(a, b){return a - b});
    // now points[0] contains the lowest value
    // and points[points.length-1] contains the highest value

    * 이렇게 아니면, for문을 통해 직접 최대/최소 값 반환하는 함수 만들어서 사용

14-2) array의 원소가 숫자인경우(수의 최대/최소 비교)    
    Math.max.aplly(null, 배열명)
    ex)
        function myArrayMax(arr) {
             return Math.max.apply(null, arr);
        }

    Math.min.apply(null, 배열명)
    ex)
        function myArrayMin(arr) {
            return Math.min.apply(null, arr);
        }

array iteration(반복 처리) 
1) forEach()
    기능: array 각각 원소를 한번씩 모두 호출하는 callback함수로 array의 원소들 각각을 반환

    ex1)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value, index, array) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }
    
    ex2)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }

        ex1과 ex2의 결과는 동일

2) map()
    기능: forEach처럼 array의 각 원소들을 index순서로 순회하며 각각의 원소값 모아, array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

    ex2)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

3) array filter()
    기능: array의 원소들 중 특정 조건에 부합하는 원소들만 모아서 array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value) {
        return value > 18;
    }

4) reduce()
    기능: array의 원소들을 index순서대로(오름차순) 순회하며 각각의 값을 순차적으로 삭제, 만약 인자로 입력된 값에 return값이 있는 경우 return값을 반환 
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

    ex3)    :특정 값으로 초기값을 지정할 수 있다.
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction, 100); //초기값을 100으로 지정하고 연산 시작

    function myFunction(total, value) {
        return total + value;
    }

5) every()
    기능: array의 모든 원소들을 index순서(오름차순)로 순회하며 각각의 원소 값이 특정 조건에 만족하는 지 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

6) some()
    기능: array의 원소 중 1개라도 indext순서(오름차순)로 순회하며 확인했을 때, 특정 조건을 만족하는 지 여부를 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value, index, array) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

    ex2)
        const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

7) indexOf()
    기능: array의 원소들 중 입력받읕 특정 값의 index를 반환(숫자로)
    형태: indextOf(찾을 원소값, 검색을 시작할 index번호)

    ex)
    const fruits = ["Apple", "Orange", "Apple", "Mango"];
    let position = fruits.indexOf("Apple") + 1; // index가 0부터 시작이므로 +1을 추가해서 사람이 일반적으로 순서를 셀 때 쓰는 서수 형태 맞추기

8) find()
    * 원소 값을 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개만을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.find(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 25
    // 25와 29 모두 만족하지만, 가장 먼저 조건을 충족하는 원소가 25이므로 25만 반환

9) findIndex()
    * index를 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개의 index값을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 3

10) Array.from()
    기능: 인자로 입력받은 값을 개별 "문자"별로 쪼개어 array를 생성
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

11) keys()
    * array의 key는 index이다.
    기능: array(object)를 구성하는 원소들 중 모든 "key"값만을 순차적으로 순회 및 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const keys = fruits.keys();

    for (let x of keys) {
        text += x + " ";
    }
    // 0 1 2 3 

12) includes()
    기능: array가 특정 원소값을 가지고 있는 지 순차적으로 탐색하여 확인 후 true, false를 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    fruits.includes("Mango"); // is true

* array가 const 변수로 선언되었다는 것이 array의 원소들도 재선언 및 수정이 불가능하다는 의미가 아니다.
* 해당 array가 선언된 const변수를 재선언 할 수 없다는 의미 
즉, const의 조건만 충족하면 된다.(이미 const 변수에 종속되었기 때문)
* 만약 때에 따라 다양한 변형이나 재선언을 시도할 경우 처음부터 array를 var이나 let으로 선언하기

dates

new Date()
    * static 변수로써, 자동으로 업데이트x → 해당 메서드가 선언된 시점의 상태로 지속
    형식: 변수 = new Date()
    
* Date의 다양한 형식은 사용할 때 필요에 따라 검색으로 대체하여 사용 예정 (깊게 공부x)

math(수학 함수들)

1) Math.round()
    입력받은 인자를 반올림

2) Math.ceil()
    입력받은 인자를 올림

3) Math.floor()
    입력받은 인자를 내림

4) Math.trunc()
    입력받은 인자에서 "정수"부분만 추출하여 반환

5) Math.pow()
    형식: Math.pow(인자1, 인자2)
    기능: 인자1^인자2의 값을 반환   *거듭제곱(power)의 약자

6) Math.sqrt()
    입력받은 인자의 제곱근을 반환   *squaroot의 약자

7) Math.abs()
    입력받은 인자의 절대값을 반환   *absolute의 약자

8) Math.max() / Math.min()
    입력받은 인자의 최대, 최소 값 반환

9) Math.random()
    0~1까지의 값 중 랜덤으로 값을 반환(소수형태로 반환)

random
    random 함수의 특성활용해서 필요에 맞게 가공하기
    random함수는 0~1까지의 수를 반환

    ex)
        Math.floor(Math.random()*10)    //1자리 정수의 값으로 반환(즉 0~9까지의 수가 랜덤으로 반환)
        Math.floor(Math.random()*10)+1  //1자리 정수+10까지의 값으로 반환(즉 1~10까지의 수가 랜덤으로 반환)

Boolean
    타 언어의 boolean함수와 동일

comparison operations
* JS는 독특한 비교연산자가 존재!
* 별다른 이유가 없다면 JS마스터가 아니고서는 "===" 비교연산자 사용하기(예상하지 못한 error를 사전에 방지가능)

    * x = 5라고 값이 지정된 경우,
    Operator	Description	                        Comparing	Returns	
    ==	        값 동일	                             x == 8	    false	
                                                    x == 5	    true	
                                                    x == "5"	true	
    ===	        값 동일, 데이터 형식 동일   	     x === 5	  true	
                                                    x === "5"	false	
    !=	        값이 다른 경우 	                     x != 8	    true	
    !==	        값이 다르거나, 데이터형식이 다른 경우 x !== 5	    false	
                                                    x !== "5"	true	
                                                    x !== 8	    true	
    >	        크다        	                    x > 8	    false	
    <	        작다       	                        x < 8	    true	
    >=	        크거나 같다             	        x >= 8	    false	
    <=	        작거나 같다         	            x <= 8	    true

logical operations

    * x=6, y=3이 선언되었을 때,
    Operator	Description	        Example	
    &&	        and	                (x < 10 && y > 1) is true	
    ||	        or	                (x == 5 || y == 5) is false	
    !	        not	                !(x == y) is true

lambda operations
    형식: 변수 = (조건) ? 값1 : 값2
        * 조건이 true이면 값1을, false면 값2를 반환

conditions(조건문)
    Java의 조건문과 동일
    if/     else if     /else

switch(스위치문)
    Java의 스위치문과 동일
    * case의 값으로는 "숫자"만 가능!
    
    형식:
        switch(expression) {
            case x:                 //x인 경우
                // code block
                break;
            case y:                 //y인 경우
                // code block
                break;
            default:                // 기본값(일치 값이 없는 경우)
                // code block
        }

for (for문)
    for문 자체의 사용방법: java의 for문과 동일

for in
    for 문 내부의 애트리뷰트로 in을 사용

    1) 배열에 for in 사용 → index number을 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 number를 반환)
            result += object[key];
        }

    2) 객체(object)에 for in 사용 → key를 반환
    ex)
        const object = [first: "a", second: "b", third: "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 key를 반환)
            result += object[key];
        }

for of
    for 문 내부의 애트리뷰트로 of를 사용    

    배열의 값을 반환(index number이 아닌, value를 반환)
    객체 역시 value를 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key of object){         // python의 in 과 동일한 역할 수행(배열 내 각 원소들를 반환)
            result += key;
        }

while
    Java의 while문과 동일한 문법

do while    :while과 동일한 역할을 하지만, 조건이 충족되기 전에 먼저 실행부터 하고 조건을 확인한 뒤 이후의 연산을 결정
    ex)
        do{
            ...
        }
        while{
            ...
        }

분기문
break       :해당 반복을 종료           //java, python의  break와 동일
continue    :아래의 코드를 무시하고 다음 반복을 실행    //java의 continue, python의 pass와 동일

iterables
    1) String
    2) Array / Object 

    * 위의 두가지 자료형이 반복이 가능한 자료형(반복문 사용가능 )

set
    개념: '집합' 자료형
    * set 내에는 중복되는 원소가 존재할 수 없다.(집합의 정의에 의해)
    * set의 원소로 동일한 원소가 중복으로 입력되면 무시한다.

    Method	        Description
    new Set()	    새로운 집합(비어있는 집합)을 생성
    add()	        원소를 가장 마지막에 추가
    delete()    	인자로 입력받은 원소 삭제(index가 아니라, element를 인자로 입력해야 한다.)
    has()       	인자로 입력받은 원소가 set 안에 있으면 true, 없으면 false반환
    forEach()   	set이 원소로 가지고 있는 모든 원소들을 좌→우 순서로 순회하며 callback(반환)한다.
        ex)
            const letters = new Set(["a","b","c"]);

            let text = "";
            letters.forEach (function(value) {
                text += value;
            })

    values()    	set의 모든 원소를 반환
        ex)

            let text = "";
            for (const x of letters.values()) {
                text += x;
            }
    
maps
    object처럼 dictionary자료형 역할을 할 수 있는 자료형
    개별 [key: value] 쌍으로 구성
    형식:
        ex) 직접선언
        const fruits = new Map([
            ["apples", 500],
            ["bananas", 300],
            ["oranges", 200]
        ]);

        ex) 이후 추가
        const fruits = new Map();

        fruits.set("apples", 500);
        fruits.set("bananas", 300);
        fruits.set("oranges", 200);

    메서드 종류
        Method	        Description
        new Map()	    map 생성
        set()	        map의 key값과 value값 생성
        get()	        map의 특정 key값과 value값을 가져와서 반환
        delete()	    특정 key값을 입력받아, 해당하는 원소를 map에서 제거(key와 value 동시에 제거)
        has()	        특정 key값을 입력받아, 해당하는 원소가 map에 존재하는 지 여부 확인 후 true/false 반환
        forEach()	    map의 각 원소들을 반환(이때, key와 value 모두 각 원소들을 순회하며 반환) → 세부적으로 key, value 중 필요한 값을 선택 가능
        entries()	    각 원소들을 순회하며 key와 value 모두 동시에 반환

        Property	    Description
        size	        map의 원소 수를 반환
    

* objects vs maps
    
    	            Object	                            Map
        Iterable	Not directly iterable	            Directly iterable
        Size	    Do not have a size property	        Have a size property
        Key Types	Keys must be Strings (or Symbols)	Keys can be any datatype
        Key Order	Keys are not well ordered	        Keys are ordered by insertion
        Defaults	Have default keys	                Do not have default keys

typeOf
    1) 값을 담을 수 있는 자료형:
        string
        number
        boolean
        object
        function
    
    2) 객체인 자료형:
        Object
        Date
        Array
        String
        Number
        Boolean
    
    3) 값을 가질 수 없는 자료형:
        null
        undefined
    
논리연산자
    형태    의미
    &&      and
    ||      or
    !       not

