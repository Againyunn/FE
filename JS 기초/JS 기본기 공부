JS 기본적인 활용

JS는 html과 연결될 때, class 단위가 아니라, 특정 HTML element에 적용할 때 주로 "getElementById("아이디 명")"의 형태로 "id"기준으로 HTML element를 호출한다.
그러므로, head / body 어디에 JS코드가 위치하든 <script>  </script> 태그 사이에 코드들을 정의하고 getElementById("아이디 명")으로 HTML element와 연결한다.

output
- display할 수 있는 방법:
    1) innerHTML        :HTML 엘리먼트 안에 특정 내용을 JS 코드로 직접 입력
    2) document.write() :해당 코드가 위치한 곳에 JS 코드로 직접 입력 → <script> 가 body에 선언되었을 때도 사용할 수 있으며, 여러 HTML tag에 이어서 JS코드가 선언된 위치에 값을 바로 반환
        * HTML 엘리먼트가 생성 된 후 document.write()을 사용하면 생성된 HTML 의 모든 엘리먼트가 삭제되고 JS코드로 작성한 내용만 표기된다.(ex : onclick 메서드와 같은 애트리뷰트 이용 시)

    3) window.alert()   :브라우져의 "알림창"으로 JS코드로 입력된 값을 반환
    4) console.log()    :브라우져의 "콘솔 창"으로 JS코드로 입력된 값을 반환

* JS는 python, java, C등과 다르게 자체적인 "print()"메서드가 없다.
    window.print() 는 웹 페이지를 인쇄한다는 명령어

JS 주요 제어자
    Keyword	    Description
    var	        변수 재선언 가능, 재할당 가능(orriding 가능)
    let	        변수 재선언 불가, 재할당 가능(orriding 가능)
    const	    변수 재선언 불가, 재할당 불가능
    if	        조건문
    switch	    switch문
    for	        반복문
    function	함수 정의
    return	    함수 종료 및 반환 값
    try	        예외처리 블럭

variables
* 블럭 선언 불가능
재선언 가능
    ex) var x = 5; var x = 6; 

재할당 가능
    ex) var x = 0; x =5;

let
* 블럭으로 선언가능 {} 사용가능
재선언 불가능  
    ex) let x = 6; let x = 7;      //Syntax error 발생

재할당 가능
    ex) let x = 0; x = 5;       

const
* 블럭으로 선언가능 {} 사용가능
재선언 불가능
재할당 불가능 
* 처음 선언할 때의 형태 그대로만 사용가능

연산자 및 증감자는 JAvA와 동일(축약 연산자도 동일)

data types
python처럼 변수의 데이터형을 프로그램이 알아서 해석

주요 특징:
    1) 타 언어와 마찬가지로, 숫자+String(문자/문자열) = 모두 문자열로 바꾸어 연산한다.
    2) 연산에 순서가 존재(동일한 내용이더라도 순서가 다르면 결과가 달라질 수 있다.)
        ex) 
            경우1: let x = 16 + 4 + "Hello"     //"20Hello"
            경우2: let x = "Hello" + 16 + 4     //"Hello164"
        
function
1) 함수 자체로 선언하기
    function myWorld(a, b){
        ...
        return 
    }
2) 변수에 함수 생성
    const myWorld=(a, b) => {
        ...
        return
    }

object(객체)
* 일반적으로 "객체" 선언 시에는 const를 사용한다.

* 객체 내의 여러 값들을 지정할 경우 python의 dictionary와 유사하게 선언(python → car = {type: "Fiat", model: "500", color: "white"})
자료형 변수명 = {name1:"value1", name2:"value2"...}
ex) 
    const car = {type: "Fiat", model: "500", color: "white"};

accessing object properties에 접근하는 방법
방법1:
    objectName.propertyName

방법2:
    objectName["propertyName"]

* 타 언어와 다른 점은 "객체(상수, 변수)"에 "함수"를 담을 수 있다는 점
ex) 
    cosnt oneMan={
        firstName: "John",
        lastName: "Joe",
        id: 0523;
        fullName : fuction(){
            return this.firstName + " " + this.lastName;    // this를 통해서 해당 객체 내부에 선언된 변수를 재귀대명사처럼 지칭가능(Java의 this와 동일)
        }
    }

accessing object methods
방법:
    objectName.methodName()         //타 언어와 동일

* 주의:
    String, Number, Boolean 등의 객체의 데이터형을 변수에 선언하기x → 프로그램의 실행속도가 늦어지게 만들 수 있다.
    ex) x = new String(); // 이런식으로 선언x


HTML event 사용하기
HTML tag 내부에서 사용:
    <element event = "JS 코드"> 형식으로 사용

자주사용하는 HTML events
    Event	            Description
    onchange	        html 엘리먼트가 바뀌었을 때
    onclick	            html 엘리먼트를 클릭했을 때
    onmouseover	        html 엘리먼트에 마우스를 올렸을 때
    onmouseout	        html 엘리먼트에 마우스를 댔다가 떼었을 때
    onkeydown	        사용자가 키보드 자판을 눌렀을 때
    onload	            브라우져가 로딩을 다 끝냈을 때(페이지 생성을 다 끝냈을 때)

string
""와 ''를 모두 사용가능
    ex) let a = "It's a apple.";

길이 메서드
    string객체.length       //Java와 동일

인용문자 표기
    Code	Result	Description
    \'	    '	    Single quote
    \"	    "	    Double quote
    \\	    \	    Backslash

escape sequences
* html에서는 사용x, 주로 백그라운드 프로그램의 연산, 함수에 이용
    Code	Result
    \b	    Backspace
    \f  	Form Feed
    \n	    New Line
    \r	    Carriage Return
    \t	    Horizontal Tabulator
    \v	    Vertical Tabulator

string methods
1) extracting string parts(string의 일부를 추출)
    slice(start, end)
        시작~ 끝까지의 "문자열 index"를 입력
    
    substring(start, end)
        시작~ 끝까지의 "문자"를 입력(부문자열 입력)

    substr(start, length)
        시작의 indext와 길이(index길이)를 입력
    
2) replacing string content(string를 수정)
    string문자열.replace("변경의 대상", "변경할 대상")
    * replace 메서드는 해당 string의 원형을 변경하지 않는다. 변경된 것을 반환만 한다. 그러므로 반환된 객체를 받을 변수가 필요하다.
    * 소문자/대문자의 형태로 동일하게 맞춰야 한다.
    ex)
        let text = "We'll take yellow";
        let newText = text.replace("yellow", "skyblue")
    * 정규식을 통해 조건을 구체화할 수 있다.
    ex) 
        let text = "We'll take yellow!";
        let newText = text.replace("/yellow/g", "skyblue")  // /ge  : 뒤에 문자가 더 있는 경우로 제한

3) 대/소문자 변경
    toUpperCase()   :대문자로 변경
    toLowerCase()   :소문자로 변경

4) 공백 없애기
    trim()      :해당 string 내부의 공백을 없앤다

5) extracting string charactors(문자만을 추출)  
    charAt(indexNum)
        해당 인덱스에 해당하는 문자를 반환 

    charCodeAt(indexNum)
        해당 인덱스에 해당하는 문자의 unicode를 반환

6) string split(문자열을 구분하여 배열로 저장)  
    문자열.split("구분할 방식")
        ex)
            let nums= "0, 1, 2, 3, 4, 5";
            const numsArray= nums.split(", ");
            console.log(numsArray[1]);          // 1 반환           
    
        ex)
            let hello="Hello";
            const helloArray= hello.split("");
            console.log(helloArray[1]);          // e 반환

string search
1) indextOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 첫번째 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)
    ex)     
        let str = "Please locate where 'locate' occurs!";
        str.indexOf("locate");

2) lastIndexOf()
    입력받은 문자열(문자)가 대상 문자열에서 몇 번째 index인지, 시작하는 index number를 반환(동일한 text가 여러 개 있으면 마지막 text만 반환)
    * 만약 -1이 반환되면 해당 text를 찾을 수 없는 상태(not found)

3) search()
    indexOf와 거의 동일한 역할 수행

4) match()
    입력받은 문자와 동일한 문자가 해당 문자에 있는 지 확인하고 존재하면 입력받은 문자들 배열의 형태로 반환
    ex) 
        let text = "The rain in SPAIN stays mainly in plain.";
        text.match(/ain/g);         // ain,ain,ain

5) includes()
    입력받은 문자가 해당 문자에 존재하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.includes("world");             // true

6) startsWith()
    입력받은 문자로 해당 문자열이 시작하는 지 여부를 판별(true / false)
    ex)
        let text = "Hello world, welcome to the universe.";
        text.startsWith("Hello");           // true

7) endsWith()
    입력받은 문자로 해당 문자열로 끝는 지 여부를 판별(true / false)
    ex)
        var text = "John Doe";
        text.endsWith("Doe");               // true

template literals
    표현식:
        ` 문자(열) ` 
    활용:
        1) 문자열 "" 나 '' 대신 사용 가능
        2) 문자열 내부에 "" 나 ''를 제약 없이 사용가능
        3) 문자열이지만, 줄 바꿈을 허용
        4) 변수의 format 서식자 사용가능
            ex)
                let firstName = "John";
                let lastName = "Doe";   
                let text = `Welcome ${firstName}, ${lastName}!`;
        5) 문자열 내부의 변수간 연산을 허용
            ex)
                let price = 10;
                let VAT = 0.25;
                let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;
        6) HTML tag(element)도 직접 사용가능
            ex)
                let header = "Templates Literals";
                let tags = ["template literals", "javascript", "es6"];

                let html = `<h2>${header}</h2><ul>`;
                for (const x of tags) {

                html += `<li>${x}</li>`;
                }

                html += `</ul>`;

number
* number와 string 간 덧셈 연산을 해도, 이를 string간의 연산으로 간주한다.
ex) let x = "10";
    let y = 20;
    let z = x + y; // 1020

* 그 외의 연산은 string을 number로 compile한 뒤 연산한다.

무한    :infinity

number methods
1) toString()
    숫자를 문자로 전환
    ex) let x = 523;
        x.toString();

    ex) (123).toString();
        (100 + 23).toSting();

2) toFixed()
    소수점 자리를 고정
    ex) let x = 9.656;
        x.toFixed(0);   //9
        x.toFixed(2);   //9.65
        x.tofixed(4);   //9.6560

3) toExponential()
    소수점 특정 자리에서 "반올림"
    ex) let x = 9.656;
        x.toExponential(0);   //9
        x.toExponential(2);   //9.65
        x.toExponential(4);   //9.6560

4) Number()
    객체를 "수"로 변환

5) parseFloat()
    객체를 실수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

6) parseInt()
    객체를 정수로 변환(문자와 섞여있으면, 숫자만을 분리하여 인식)

7) max()
    입력받은 숫자 중 가장 큰 수를 반환

8) min()
    입력받은 숫자 중 가장 작은 수를 반환

array
* 배열은 주로 const를 활용한다.
    ex)
        const color = ["white", "green", "yellow"];

그 외의 기본적인 array관련 문법은 타 언어와 동일

HTML tag 내부에 자동으로 ,를 생성하여 출력된다.
ex)
    const color = ["white", "green", "yellow"];
    document.getElementById("root").innerHTML = color;  //white, green, yellow

배열 내의 원소(index) 간 datatype이 달라도 된다.
    ex)
        const person = ["John", "Lucas" , 26];  // 이렇게 넣어도 오류 발생x

array 내부에 object(객체)를 넣을 수 있다.
    1) 객체+메서드 넣기
        ex) myArray[0] = Date.now;
    
    2) 함수 넣기
        ex) myArray[1] = myFunction;    //function 함수 넣기
    
    3) 객체 넣기
        ex) myArray[2] = myCars;    //object 객체 넣기

array(배열) vs object(객체)
    * 둘의 가장 큰 차이: 호출 방식이 배열은 "number index", 객체는 "named index"
    array:    const person = ["John", "Lucas" , 26];
    호출방법:   cosnt result = person[0];   //John

    object:   const person = {firstName: "John", nickName: "Lucas", age: 26};   //python 의 dictionary와 유사
    호출방법:   const result = person.firstName;    //John

adding array elements
    const fruits = ["Banana", "Orange" ,"Apple"];
    fruits.push("Lemon");   // stack이나 queue처럼 push를 통해 새로운 원소가 배열의 맨 끝에 추가된다.

* JS가 인식하는 array의 타입
    typeOf 메서드 활용 →  object로 반환한다.


array method
1) toString()
    배열의 원소들을 모아, 문자열로 반환(각 원소 사이에 ,를 자동삽입)

    ex)
        const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.toString();      //Banana,Orange
        // toString메서드 내부에 넣지 않고, 객체의 메서드로 적용(인자 넣지x)
    
2) join()
    배열의 원소들을 모아, 각 인덱스별로 특정 문자를 넣어 문자열로 반환
    
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.join(" * ");      //Banana * Orange
        // python의 join과 동일한 역할 수행

3) pop()
    배열의 가장 마지막 원소를 삭제 후 반환(pop의 내부 인자로 값을 넣어도, 해당 배열의 마지막 원소만을 삭제 후 반환)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.pop(); 

4) push()
    배열의 가장 마지막 원소로 새로운 원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.push("Mango");

5) shift()
    배열의 가장 첫번째 원소를 삭제하고 모든 원소들의 index를 하나씩 당기고, 재조합된(첫번째 원소가 삭제된)배열을 반환(삭제된 배열의 index를 빈값으로 유지x)
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.shift();     //Orange

6) unshift()
    배열의 첫번째 인덱스에 특정원소를 추가
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.unshift("Mango");     //Mango,Banana,Orange

7) length
    배열의 원소 수를 반환
    ex) const fruits= ["Banana", "Orange"];
        docuemnt.getElementById("root").innerHTML = fruits.length; //2

8) concat()
    배열끼리의 병합
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        cosnt myChildren = myGirls.concat(myBoys);  //Cecile,Lone,Emil,Tom
    
    * 여러 개의 배열을 한번에 병합도 가능하다.
    ex) const myGirls = ["Cecile", "Lone"];
        const myBoys = ["Emil", "Tom"];
        const myPuppy = ["guembee"]
        cosnt myChildren = myGirls.concat(myBoys, myPuppy);  //Cecile,Lone,Emil,Tom,guembee

9) splice()
    형식:   splice(추가할 인덱스 위치, 삭제할 원소 수, 추가할 원자들1, 추가할 원자들2 ...)
    * 원본 array의 원소에 영향을 미친다.
    
    특정 위치에 원소 삽입
    ex) 
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 0, "Lemon", "Kiwi");   //Banana,Orange,Lemon,Kiwi,Apple,Mango

    특정 위치의 원소 삭제
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.splice(2, 2, "Lemon", "Kiwi");   //Orange,Apple,Mango
    
10) slice
    * 원본 array에 영향x, 새롭게 변경된 array를 생성하여 반환
    * 자를 위치의 인덱스 앞까지의 원소들을 새로운 array로 생성하여 반환
    형식:   slice(자를 인덱스 번호)

    ex)
        const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
        const citrus = fruits.slice(1); //Banana
        //  원본 배열인 fruits는 그대로 존재, 새롭게 생성된 배열 citrus만 생성

11) sort()
    오름차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.sort();      //Apple,Banana,Mango,Orange

    숫자의 오름차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return a - b});  // 1,5,10,25,40,100
    
    숫자의 내림차순 정렬
    ex) const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return b - a});  // 100,40,25,10,5,1

12) reverse()
    내림차순 정렬 메서드
    ex)
        const fruits = ["Banana", "Orange", "Apple", "Mango"];
        fruits.reverse();    

13) function(a,b){return a-b}
    비교함수
    (일반적으로 sort함수 내에 넣어서 사용)

    random 순서로 배열
    ex) 
        const points = [40, 100, 1, 5, 25, 10];
        points.sort(function(a, b){return 0.5 - Math.random()});
    
    활용 예시)
    <button onclick="myFunction()">Try it</button>
    <p id="demo"></p>

    <script>
        const points = [40, 100, 1, 5, 25, 10];
        document.getElementById("demo").innerHTML = points;  

        function myFunction() {
            points.sort(function(a, b){return 0.5 - Math.random()});
            document.getElementById("demo").innerHTML = points;
        }
    </script>

* JS 자체적으로는 array의 원소들을 자체적으로 비교하려 최대/소 값을 반환하는 max, min함수가 없다.
14-1) max/min 대신에 sort한 뒤에 새롭게 생성된 array에서 첫번째/ 마지막 인덱스를 반환하는 방식으로 최소/최대 값을 구한다.
    ex)
    const points = [40, 100, 1, 5, 25, 10];
    points.sort(function(a, b){return a - b});
    // now points[0] contains the lowest value
    // and points[points.length-1] contains the highest value

    * 이렇게 아니면, for문을 통해 직접 최대/최소 값 반환하는 함수 만들어서 사용

14-2) array의 원소가 숫자인경우(수의 최대/최소 비교)    
    Math.max.aplly(null, 배열명)
    ex)
        function myArrayMax(arr) {
             return Math.max.apply(null, arr);
        }

    Math.min.apply(null, 배열명)
    ex)
        function myArrayMin(arr) {
            return Math.min.apply(null, arr);
        }

array iteration(반복 처리) 
1) forEach()
    기능: array 각각 원소를 한번씩 모두 호출하는 callback함수로 array의 원소들 각각을 반환

    ex1)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value, index, array) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }
    
    ex2)
    const numbers = [45, 4, 9, 16, 25];     //배열
    let txt = "";           //비어있는 값으로 각 배열의 원소를 순차적으로 기록하고 추가할 변수
    numbers.forEach(myFunction);    //numbers의 각 원소를 forEach() 메서드로 추가

    function myFunction(value) {  //value 인자는 필수 값, index와 array는 생략 가능
        txt += value + "<br>";
    }

        ex1과 ex2의 결과는 동일

2) map()
    기능: forEach처럼 array의 각 원소들을 index순서로 순회하며 각각의 원소값 모아, array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

    ex2)
    const numbers1 = [45, 4, 9, 16, 25];
    const numbers2 = numbers1.map(myFunction);

    function myFunction(value, index, array) {
        return value * 2;
    }

3) array filter()
    기능: array의 원소들 중 특정 조건에 부합하는 원소들만 모아서 array형태로 반환
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    const over18 = numbers.filter(myFunction);

    function myFunction(value) {
        return value > 18;
    }

4) reduce()
    기능: array의 원소들을 index순서대로(오름차순) 순회하며 각각의 값을 순차적으로 삭제, 만약 인자로 입력된 값에 return값이 있는 경우 return값을 반환 
    * 원본 array는 존재하고, 새로운 array를 생성
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

    ex3)    :특정 값으로 초기값을 지정할 수 있다.
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers.reduce(myFunction, 100); //초기값을 100으로 지정하고 연산 시작

    function myFunction(total, value) {
        return total + value;
    }

5) every()
    기능: array의 모든 원소들을 index순서(오름차순)로 순회하며 각각의 원소 값이 특정 조건에 만족하는 지 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value, index, array) {   //필수 값: total, value   선택 값: index, array
        return total + value;
    }

    ex2)
    const numbers = [45, 4, 9, 16, 25];
    let sum = numbers1.reduceRight(myFunction);

    function myFunction(total, value) {
        return total + value;
    }

6) some()
    기능: array의 원소 중 1개라도 indext순서(오름차순)로 순회하며 확인했을 때, 특정 조건을 만족하는 지 여부를 확인하여 true/false를 반환
    ex1)
    const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value, index, array) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

    ex2)
        const numbers = [45, 4, 9, 16, 25];
    let someOver18 = numbers.some(myFunction);

    function myFunction(value) {  // 필수 값: value,  선택 값: index, array
        return value > 18;
    }

7) indexOf()
    기능: array의 원소들 중 입력받읕 특정 값의 index를 반환(숫자로)
    형태: indextOf(찾을 원소값, 검색을 시작할 index번호)

    ex)
    const fruits = ["Apple", "Orange", "Apple", "Mango"];
    let position = fruits.indexOf("Apple") + 1; // index가 0부터 시작이므로 +1을 추가해서 사람이 일반적으로 순서를 셀 때 쓰는 서수 형태 맞추기

8) find()
    * 원소 값을 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개만을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.find(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 25
    // 25와 29 모두 만족하지만, 가장 먼저 조건을 충족하는 원소가 25이므로 25만 반환

9) findIndex()
    * index를 반환
    기능: array의 원소들 중 index순서대로(오름차순) 원소들을 순회하다가 특정 조건에 부합하는 원소를 찾으면 탐색 종료(좌→ 우 순서 중 가장 먼저 특정 조건을 만족하는 값 1개의 index값을 반환)
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }
    // 3

10) Array.from()
    기능: 인자로 입력받은 값을 개별 "문자"별로 쪼개어 array를 생성
    ex)
    const numbers = [4, 9, 16, 25, 29];
    let first = numbers.findIndex(myFunction);

    function myFunction(value, index, array) {
        return value > 18;
    }

11) keys()
    * array의 key는 index이다.
    기능: array(object)를 구성하는 원소들 중 모든 "key"값만을 순차적으로 순회 및 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const keys = fruits.keys();

    for (let x of keys) {
        text += x + " ";
    }
    // 0 1 2 3 

12) includes()
    기능: array가 특정 원소값을 가지고 있는 지 순차적으로 탐색하여 확인 후 true, false를 반환
    ex)
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    fruits.includes("Mango"); // is true

* array가 const 변수로 선언되었다는 것이 array의 원소들도 재선언 및 수정이 불가능하다는 의미가 아니다.
* 해당 array가 선언된 const변수를 재선언 할 수 없다는 의미 
즉, const의 조건만 충족하면 된다.(이미 const 변수에 종속되었기 때문)
* 만약 때에 따라 다양한 변형이나 재선언을 시도할 경우 처음부터 array를 var이나 let으로 선언하기

dates

new Date()
    * static 변수로써, 자동으로 업데이트x → 해당 메서드가 선언된 시점의 상태로 지속
    형식: 변수 = new Date()
    
* Date의 다양한 형식은 사용할 때 필요에 따라 검색으로 대체하여 사용 예정 (깊게 공부x)

math(수학 함수들)

1) Math.round()
    입력받은 인자를 반올림

2) Math.ceil()
    입력받은 인자를 올림

3) Math.floor()
    입력받은 인자를 내림

4) Math.trunc()
    입력받은 인자에서 "정수"부분만 추출하여 반환

5) Math.pow()
    형식: Math.pow(인자1, 인자2)
    기능: 인자1^인자2의 값을 반환   *거듭제곱(power)의 약자

6) Math.sqrt()
    입력받은 인자의 제곱근을 반환   *squaroot의 약자

7) Math.abs()
    입력받은 인자의 절대값을 반환   *absolute의 약자

8) Math.max() / Math.min()
    입력받은 인자의 최대, 최소 값 반환

9) Math.random()
    0~1까지의 값 중 랜덤으로 값을 반환(소수형태로 반환)

random
    random 함수의 특성활용해서 필요에 맞게 가공하기
    random함수는 0~1까지의 수를 반환

    ex)
        Math.floor(Math.random()*10)    //1자리 정수의 값으로 반환(즉 0~9까지의 수가 랜덤으로 반환)
        Math.floor(Math.random()*10)+1  //1자리 정수+10까지의 값으로 반환(즉 1~10까지의 수가 랜덤으로 반환)

Boolean
    타 언어의 boolean함수와 동일

comparison operations
* JS는 독특한 비교연산자가 존재!
* 별다른 이유가 없다면 JS마스터가 아니고서는 "===" 비교연산자 사용하기(예상하지 못한 error를 사전에 방지가능)

    * x = 5라고 값이 지정된 경우,
    Operator	Description	                        Comparing	Returns	
    ==	        값 동일	                             x == 8	    false	
                                                    x == 5	    true	
                                                    x == "5"	true	
    ===	        값 동일, 데이터 형식 동일   	     x === 5	  true	
                                                    x === "5"	false	
    !=	        값이 다른 경우 	                     x != 8	    true	
    !==	        값이 다르거나, 데이터형식이 다른 경우 x !== 5	    false	
                                                    x !== "5"	true	
                                                    x !== 8	    true	
    >	        크다        	                    x > 8	    false	
    <	        작다       	                        x < 8	    true	
    >=	        크거나 같다             	        x >= 8	    false	
    <=	        작거나 같다         	            x <= 8	    true

logical operations

    * x=6, y=3이 선언되었을 때,
    Operator	Description	        Example	
    &&	        and	                (x < 10 && y > 1) is true	
    ||	        or	                (x == 5 || y == 5) is false	
    !	        not	                !(x == y) is true

lambda operations
    형식: 변수 = (조건) ? 값1 : 값2
        * 조건이 true이면 값1을, false면 값2를 반환

conditions(조건문)
    Java의 조건문과 동일
    if/     else if     /else

switch(스위치문)
    Java의 스위치문과 동일
    * case의 값으로는 "숫자"만 가능!
    
    형식:
        switch(expression) {
            case x:                 //x인 경우
                // code block
                break;
            case y:                 //y인 경우
                // code block
                break;
            default:                // 기본값(일치 값이 없는 경우)
                // code block
        }

for (for문)
    for문 자체의 사용방법: java의 for문과 동일

for in
    for 문 내부의 애트리뷰트로 in을 사용

    1) 배열에 for in 사용 → index number을 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 number를 반환)
            result += object[key];
        }

    2) 객체(object)에 for in 사용 → key를 반환
    ex)
        const object = [first: "a", second: "b", third: "c"];
        const result = "";
        for(var key in object){         // python의 range in 과 동일한 역할 수행(배열 index의 key를 반환)
            result += object[key];
        }

for of
    for 문 내부의 애트리뷰트로 of를 사용    

    배열의 값을 반환(index number이 아닌, value를 반환)
    객체 역시 value를 반환
    ex)
        const object = ["a", "b", "c"];
        const result = "";
        for(var key of object){         // python의 in 과 동일한 역할 수행(배열 내 각 원소들를 반환)
            result += key;
        }

while
    Java의 while문과 동일한 문법

do while    :while과 동일한 역할을 하지만, 조건이 충족되기 전에 먼저 실행부터 하고 조건을 확인한 뒤 이후의 연산을 결정
    ex)
        do{
            ...
        }
        while{
            ...
        }

분기문
break       :해당 반복을 종료           //java, python의  break와 동일
continue    :아래의 코드를 무시하고 다음 반복을 실행    //java의 continue, python의 pass와 동일

iterables
    1) String
    2) Array / Object 

    * 위의 두가지 자료형이 반복이 가능한 자료형(반복문 사용가능 )

set
    개념: '집합' 자료형
    * set 내에는 중복되는 원소가 존재할 수 없다.(집합의 정의에 의해)
    * set의 원소로 동일한 원소가 중복으로 입력되면 무시한다.

    Method	        Description
    new Set()	    새로운 집합(비어있는 집합)을 생성
    add()	        원소를 가장 마지막에 추가
    delete()    	인자로 입력받은 원소 삭제(index가 아니라, element를 인자로 입력해야 한다.)
    has()       	인자로 입력받은 원소가 set 안에 있으면 true, 없으면 false반환
    forEach()   	set이 원소로 가지고 있는 모든 원소들을 좌→우 순서로 순회하며 callback(반환)한다.
        ex)
            const letters = new Set(["a","b","c"]);

            let text = "";
            letters.forEach (function(value) {
                text += value;
            })

    values()    	set의 모든 원소를 반환
        ex)

            let text = "";
            for (const x of letters.values()) {
                text += x;
            }
    
maps
    object처럼 dictionary자료형 역할을 할 수 있는 자료형
    개별 [key: value] 쌍으로 구성
    형식:
        ex) 직접선언
        const fruits = new Map([
            ["apples", 500],
            ["bananas", 300],
            ["oranges", 200]
        ]);

        ex) 이후 추가
        const fruits = new Map();

        fruits.set("apples", 500);
        fruits.set("bananas", 300);
        fruits.set("oranges", 200);

    메서드 종류
        Method	        Description
        new Map()	    map 생성
        set()	        map의 key값과 value값 생성
        get()	        map의 특정 key값과 value값을 가져와서 반환
        delete()	    특정 key값을 입력받아, 해당하는 원소를 map에서 제거(key와 value 동시에 제거)
        has()	        특정 key값을 입력받아, 해당하는 원소가 map에 존재하는 지 여부 확인 후 true/false 반환
        forEach()	    map의 각 원소들을 반환(이때, key와 value 모두 각 원소들을 순회하며 반환) → 세부적으로 key, value 중 필요한 값을 선택 가능
        entries()	    각 원소들을 순회하며 key와 value 모두 동시에 반환

        Property	    Description
        size	        map의 원소 수를 반환
    

* objects vs maps
    
    	            Object	                            Map
        Iterable	Not directly iterable	            Directly iterable
        Size	    Do not have a size property	        Have a size property
        Key Types	Keys must be Strings (or Symbols)	Keys can be any datatype
        Key Order	Keys are not well ordered	        Keys are ordered by insertion
        Defaults	Have default keys	                Do not have default keys

typeOf
    1) 값을 담을 수 있는 자료형:
        string
        number
        boolean
        object
        function
    
    2) 객체인 자료형:
        Object
        Date
        Array
        String
        Number
        Boolean
    
    3) 값을 가질 수 없는 자료형:
        null
        undefined


error
    try         :시도해볼 코드
    catch       :error을 만났을 때 대처할 코드
    finally     :결과에 상관없이 코드를 실행
    throw       :개발자가 의도된 에러를 만들 때 실행

    형식:
        try{
            시도할 코드
        }
        catch(err){
            에러에 대처할 코드
        }
    
    throw 사용법:

    * String,   Number, Boolean, Object형태로 선언가능
        throw "Too Big.";
        throw 500;
    ex)
        <html>
        <body>

            <h2>JavaScript try catch</h2>

            <p>Please input a number between 5 and 10:</p>

            <input id="root" type="text">
            <button type="button" onclick="myFunction()">Test Input</button>
            <p id="p01"></p>

            <script>
                function myFunction() {
                    const message = document.getElementById("p01");
                    message.innerHTML = "";
                    let x = document.getElementById("root").value;
                    try { 
                        if(x == "")  throw "empty";         //상황에 맞게 custom error를 정의
                        if(isNaN(x)) throw "not a number";
                        x = Number(x);
                        if(x < 5)  throw "too low";
                        if(x > 10)   throw "too high";
                    }
                    catch(err) {
                        message.innerHTML = "Input is " + err;  //해당 error를 html로 보내서 출력
                    }
                    finally{
                        document.getElementById("root").value="";   //error 유무에 상관없이 실행할 코드 정의(조회수 기록, 연산 등 수행 목적으로 쓰일 것으로 보임)
                    }
                }
            </script>

        </body>
        </html>

block Scope
    let변수는 { } 밖에서 사용 불가능
    var변수는 { } 밖에서 사용 가능

    function 내에 선언된 모든 변수는 function 내에서만 사용 가능  
    ex)
        function myFunction(){
            let pizzaName = "Cheese";
        }   //함수 밖에서 pizzaName 변수 사용 불가능


hoisting

    1) var  
    * var변수에 한하여 hoisting가능하다
    특징: 변수들이 선언되기 전에 사용될 수 있다.
    * 변수를 우선 사용한 뒤, 선언가능
    ex) 
        // 선언 전에 변수를 선제 사용
        x = 5;  
        elements = document.getElementById("root");
        element.innerHTML = x;
        // 변수의 후 선언
        var x;

    * 단 var이 hoisting 될 때에는 var에 값이 지정된 상태일 때만 가능하다.

    2) let, const
    * let과 const 두 변수들은 hoisting 사용이 불가능하다.

strict mode
    *JS의 자유로움으로 인하여 예상치 못한 error가 발생하는 것을 방지하기 위한 방법
    ex)
        "use strict";
        myFunction();

        function myFunction() {
            y = 3.14;   // strict mode로 인해 선언되지 않은 변수y는 hoisting을 허용하지 않는다.(타 언어들처럼 엄격한 규칙을 가지게 된다.)
        }
    

    strict mode에서 허용하지 않는 것:
        1) hoisting
        2) 변수/객체/함수의 삭제  delete 명령어
        3) 중복된 변수의 사용
        4) 0이 첫번째 자리로 오는 숫자
        5) escape charactors
        등..
        더 많은 내용은 링크 참고 (https://www.w3schools.com/js/js_strict.asp)
    
arrow function
    함수 선언의 축약형
    
    사용법의 차이
    ex) 일반적 함수 선언
        hello = function() {
            return "Hello World.";
        }
    ex) arrow function
        hello = () =>{
            return "Hello World.";
        }
    
    this 메서드의 인식 차이
    ex) 일반적 함수 선언
        hello = function() {
            document.getElementById("root").innerHTML += this;      //this는 함수를 담은 외부의 객체를 지칭
        }
    
    ex) arrow function
        hello = () => {
            document.getElementById("root").innerHTML += this;      //this는 함수를 가지고 있는 객체를 지칭
        }

class
    형식:
        class ClassName{        //함수 선언
            constructor(){      //생성자 선언
                ...
            }
        }
    
    ex)
        class Car {
            constructor(name, year) {   //입력받은 인자인 name과 year을 지칭
                this.name = name;
                this.year = year;
            }
        }
    
    1) constructor
    * 생성자는 반드시 constructor라는 정확한 이름으로 기재해야 한다.
    * 생성자는 객체가 생성되면 자동으로 실행
    * 객체(함수)에 모두 적용된다. → 함수에 사용될 class 내부의 전역 변수로서 개별 함수에서는 "인자(parameter)"로 쓰일 수 있다.
    선언 형식:
        class ClassName {
            constructor() { ... }   //생성자는 1개 가장 상위에 위치
            method_1() { ... }      //class의 개별 메소드들(클래스 소속 함수)
            method_2() { ... }
            method_3() { ... }
        }

    ex)
        class Car {
            constructor(name, year) {
                this.name = name;
                this.year = year;
            }
            age() {
                let date = new Date();
                return date.getFullYear() - this.year;
            }
        }

        let myCar = new Car("Ford", 2014);
        document.getElementById("demo").innerHTML =
        "My car is " + myCar.age() + " years old.";
    
JSON
    Java Script Object Notation
    특징:
        1) 가벼운 데이터에 대한 변환 포멧 존재
        2) 독립적인 언어
        3) 자기기술성이 있으며, 이해하기 쉬운 편
    
    JS의 프로그램이 JSON 데이터로 쉽게 변형될 수 있다.

    기본 형식:
        1) data는 이름/값(name/value)쌍이 맞아야 한다.
        2) data는 ,로 구분된다.
        3) 중괄호가 객체를 감싼다.
        4) 대괄호가 전체 배열을 감싼다.
    ex)
        "employees":[
            {"firstName":"John", "lastName":"Doe"},
            {"firstName":"Anna", "lastName":"Smith"},
            {"firstName":"Peter", "lastName":"Jones"}
        ]
    
    JSON을 JS로 변환하기
    1) 일반 객체를 활용해서 text 내의 employee라는 배열로 만들기
        ex)
            let text = '{ "employees" : [' +
                '{ "firstName":"John" , "lastName":"Doe" },' +
                '{ "firstName":"Anna" , "lastName":"Smith" },' +
                '{ "firstName":"Peter" , "lastName":"Jones" } ]
            }';
    
    2) JSON.parse를 활용해서 데이터의 형태를 string으로 바꾸기
        ex)
            const obj = JSON.parse(text);
    
     → obj.employee[1].firstname 을 호출하면 "Anna"가 반환된다.
     만약 JSON.parse로 JSON의 데이터를 담은 JS변수를 string으로 변환하지 않으면 정상적으로 출력이 안된다.
     (text.employee[1].firstname을 호출하면 아무런 결과도 반환되지 않는다.)

debugging
    1) console.log() 사용
        JS의 코드를 web browser을 통해 보여준다.
    
    2) debugger; 키워드
        debugg할 때 breakpoint를 지정
        
        ex)
            let x = 15 * 5;
            debugger;
            document.getElementById("demo").innerHTML = x;

JS 코드 짜는 Tip:
    1) 코드를 짤 때 new, ==, eval()을 가급적 사용x
    2) 변수를 가장 위에 한번에 명시하는 연습
    3) 변수를 선언할 때 반드시 "초기화"하는 연습
    4) 가능하면 변수를 const로 선언하며 데이터 형태가 의도치 않게 변형되는 것을 방지
    5) 배열 선언 시 데이터형을 const로 선언하여 데이터 형태가 의도치 않게 변형되는 것을 방지
    6) new 객체() 선언x → 속도가 느려질 수 있다.
    7) == 대신에 데이터형까지도 체크하는 ===을 사용
    8) 함수에 defualt parameter 부여하기
        ex)
            function (a=1, b=1) { /*function code*/ }
    9)switch문의 마지막은 반드시 default값으로 넣기
    10) Number, String, Boolean을 new 객체이름() 형식으로 선언해서 "객체화"하지 않기
        ex)
            let x = "John";             
            let y = new String("John");
            (x === y) // is false because x is a string and y is an object.
    
    11) 반복문 안에서 메서드 사용x, 외부에서 연산하여 반복문에서는 상수 위주로 사용하기 (속도 향상을 위해)
        ex)
            let l = arr.length;
            for (let i = 0; i < l; i++) {   // i<arr.length를 반복문 구문 내에 호출하면 매 루프 때마다 length를 계산해야 하는 중복연산이 발생
            }

    12) DOM 접근을 최소화하기  
        * DOM은 JS의 속도를 느리게 만드는 요인 중 하나
        * 따라서 DOM을 사용할 때에도 DOM의 내부 코드를 최소화하기(DOM 활용 시 코드의 간소화 필요)

        bad ex)
            let fullName = firstName + " " + lastName;
            document.getElementById("demo").innerHTML = fullName;
        
        good ex)
            document.getElementById("demo").innerHTML = firstName + " " + lastName;
    

#JS Advance
JS callbacks
    콜백 사용 이유:
        특정 기능을 선수행한 뒤, 결과값을 반환하는 것이 필요한 경우
    
    * 재귀함수와 유사한 개념으로, 재귀함수가 특정 조건 만족 시까지 연산을 반복수행하는 것과 달리, callback은 재귀연산을 1번만 수행한다.
    함수1 내에 인자로써 함수2를 입력하는 경우에 사용된다.
    이때 함수1의 인자 중 callback할 수 있는 인자의 자리에 함수2가 입력된다.
    함수1의 실행결과 callback용 변수의 인자로 실행결과를 담으면 함수2의 인자로 함수1의 실행결과가 담긴 형태가 된다. 
    
    ex)
        <html>
        <body>

            <h2>JavaScript Callbacks</h2>

            <p>Do a calculation and then display the result.</p>

            <p id="demo"></p>

            <script>
                function myDisplayer(something) {
                    document.getElementById("demo").innerHTML = something;
                }

                function myCalculator(num1, num2, myCallback) {     //인자로 myCallback을 입력
                    let sum = num1 + num2;
                    myCallback(sum);        //함수의 실행결과로써 myCallback에 변수(값)를 담아 반환
                                            //myCalculator의 myCallback인자로 myDisplayer라는 함수가 입력되었기에, 
                                            //myCalculator함수의 실행 결과에 따른 myCallback의 인자로 sum이 입력된 것은 myDisplayer의 something인자로 sum이 입력된 것을 의미.
                }

                myCalculator(5, 5, myDisplayer); //myCalculator의 인자로 함수인 myDisplayer가 입력
            </script>

        </body>
    </html>
    
asynchronous JS
    현업에서 callback을 활용할 때, 여러 메서드와 함께 사용하여 callback될 시간을 정할 수 있다.
    
    1) setTimeout()
    ex)
        <html>
        <body>
            <h2>JavaScript Callback</h2>
            <p>Wait 3 seconds (3000 milliseconds) for this page to change.</p>

            <h1d="demo"></h1>

            <script>
                setTimeout(myFunction, 3000);       //setTimeout(대상, 초설정)  :설정한 초 뒤에 대상을 실행 (1회 실행)
                                                    //일반적으로 "대상"으로 함수를 입력
                function myFunction() {
                    document.getElementById("demo").innerHTML = "I love You !!";
                }
            </script>
        </body>
        </html>

    2) setInterval()
    ex)
        <html>
        <body>

            <h2>JavaScript setInterval()</h2>

            <p>Using setInterval() to display the time every second (1000 milliseconds).</p>

            <h1 id="demo"></h1>

            <script>
                setInterval(myFunction, 1000);      //setInterval(대상, 초설정) :설정한 초 간격으로 대상을 실행(지속적으로 실행)

                function myFunction() {
                    let d = new Date();
                    document.getElementById("demo").innerHTML=
                    d.getHours() + ":" +
                    d.getMinutes() + ":" +
                    d.getSeconds();
                }
            </script>

        </body>
        </html>
    
    3) 특정 파일이 loading될 때까지 기다리기
        XMLHttpRequest() 객체를 활용
            메서드:
                open(데이터형식, 대상)
                onload
                status
                responeText
                send()
        ex)
            <html>
            <body>
                <h2>JavaScript Callbacks</h2>
                <p id="demo"></p>

                <script>
                    function myDisplayer(some) {
                        document.getElementById("demo").innerHTML = some;
                    }

                    function getFile(myCallback) {
                        let req = new XMLHttpRequest();
                        req.open('GET', "mycar.html");
                        req.onload = function() {
                            if (req.status == 200) {
                                myCallback(this.responseText);
                            } 
                            else {
                                myCallback("Error: " + req.status);
                            }
                        }
                        req.send();
                    }

                    getFile(myDisplayer); 
                </script>
            </body>
            </html>
    
HTML DOM 
    Document Object model
    DOM은 W3C(World Wide Web Consortium)의 표준으로, 언어중심 인터페이스로 프로그램과 script가 동적으로 접속하고 콘텐츠와 구조, 스타일을 최신화하는 것을 지원

    3가지 부분:
        1) Core DOM :모든 문서 형식에 대한 모델
        2) XML DOM  :XML 문서에 대한 모델
        3) HTML DOM :HTML문서에 대한 모델
    
    DOM Method: 동작
    DOM Value:  값(setting이나 변경 가능)

    ex)
        <html>
        <body>
            <p id="demo"></p>
            <script>
                document.getElementById("demo").innerHTML = "Hello World!";     // getElementById는 method이고, innerHTML은 property이다.
            </script>
        </body>
        </html>
    
    getElementById()    :HTML의 tag 속 id를 기준으로 해당 Element를 호출하여 script로 활용할 수 있는 메서드
    innerHTML           :HTML element를 가져오고 변경할 수 있는 property(* property: method 내에 있는 멤버의 기능 수행)

DOM Documents
    1) HTML Element를 찾는 메서드:

        Method	                                Description
        document.getElementById(id)	            Find an element by element id
        document.getElementsByTagName(name)	    Find elements by tag name
        document.getElementsByClassName(name)	Find elements by class name

    
        활용:
        * 모두 id, name을 입력할 때 "내용물" 형태로 입력 
            html 태그들도 <> 는 모두 없애고 <> 대신에 ""로 입력한다.

        querySelectorAll() :
            CSS selectors가 정해진 특정 값을 탐색할 경우

            ex)
                const x = document.querySelectorAll("p.intro");         //document의 메서드로 querySelectorAll("CSS Selector이름")
        

    2) HTML Element를 바꾸는 property/메서드:
        Property	                                Description
        element.innerHTML =  new html content	    Change the inner HTML of an element (HTML의 Child 값을 변경한다는 의미)
        element.attribute = new value	            Change the attribute value of an HTML element(HTML 내부의 Attribute 값을 변경한다는 의미)
        element.style.property = new style	        Change the style of an HTML element()

        Method	                                    Description
        element.setAttribute(attribute, value)	    Change the attribute value of an HTML element  
        * element.attribute 와 동일한 기능을 수행
    
        활용:
        element.attribute 예시
            형식:   document.getElementById(id).attribute = new value       // attribute로는 HTML 내부의 attribut값을 변경한다는 의미

            ex)
                <html>
                <body>
                    <img id="myImage" src="smiley.gif">
                    <script>
                        document.getElementById("myImage").src = "landscape.jpg";
                    </script>
                </body>
                </html>

        element.innerHTML 을 활용하여 JS로 동적인 값을 넣어줄 수도 있다. (동기식 처리로 인해, 새로고침을 하지 않으면 반환된 값이 정지되어있다.)
            ex)
                <script>
                    document.getElementById("myImage").src = "landscape.jpg";
                </script>

        document.write()
            * HTML의 특정위치에 직접 값을 출력할 때 활용

            ex)
            <html>
            <body>
                <p>Bla bla bla</p>
                <script>
                    document.write(Date());     // Bla bla bla 사이에 Date() 값이 바로 찍힌다.
                </script>
                <p>Bla bla bla</p>
            </body>
            </html>
                
    3) HTML Element를 추가하고 삭제하는 메서드:

        Method	                                Description
        document.createElement(element)	        Create an HTML element
        document.removeChild(element)	        Remove an HTML element
        document.appendChild(element)	        Add an HTML element
        document.replaceChild(new, old)	        Replace an HTML element
        document.write(text)	                Write into the HTML output stream
    
    4) Event hendler 메서드:
        * HTML Element를 클릭했을 때의 동작을 정의

        Method	                                                    Description
        document.getElementById(id).onclick = function(){code}	    Adding event handler code to an onclick event
    
    5) HTML Object에 대한 값을 JS로 반환하는 properties:

        Property	                    Description
        document.anchors	            Returns all <a> elements that have a name attribute	
        document.applets	            Deprecated	
        document.baseURI	            Returns the absolute base URI of the document	
        document.body	                Returns the <body> element	
        document.cookie	                Returns the document's cookie	
        document.doctype	            Returns the document's doctype	
        document.documentElement	    Returns the <html> element	
        document.documentMode	        Returns the mode used by the browser	
        document.documentURI	        Returns the URI of the document	
        document.domain	                Returns the domain name of the document server	
        document.domConfig	            Obsolete.	
        document.embeds	                Returns all <embed> elements	
        document.forms	                Returns all <form> elements	
        document.head	                Returns the <head> elements
        document.images	                Returns all <img> elements	
        document.implementation	        Returns the DOM implementation	
        document.inputEncoding	        Returns the document's encoding (character set)	
        document.lastModified	        Returns the date and time the document was updated	
        document.links	                Returns all <area> and <a> elements that have a href attribute	
        document.readyState	            Returns the (loading) status of the document	
        document.referrer	            Returns the URI of the referrer (the linking document)	
        document.scripts	            Returns all <script> elements	
        document.strictErrorChecking	Returns if error checking is enforced	
        document.title	                Returns the <title> element	
        document.URL	                Returns the complete URL of the document	

    6) form의 DOM 처리 방식
    * 원래 html로 form을 처리할 경우, 모든 값의 확인을 백엔드의 서버에서 처리해야 하므로, 서버와 통신해야 하는 시간적, 리소스 비용이 발생
    따라서 JS를 통해 html외부에서 특정 값의 유효성을 선제적으로 검사한 뒤에 적합한 값이 입력되었을 때 백엔드 서버로 값을 전송하는 방식으로 활용할 수 있다.

    데이터의 유효성 검사를 프론트단에서 처리 가능

    ex)
        <html>
        <body>
            <h2>JavaScript Validation</h2>
            <p>Please input a number between 1 and 10:</p>
            <input id="numb">
            <button type="button" onclick="myFunction()">Submit</button>
            <p id="demo"></p>
            <script>
                function myFunction() {
                    // html element 중에 id값이 "numb"인 element 내부의 값을 가져온다.
                    let x = document.getElementById("numb").value;      // property "value"를 통해 해당 element의 값을 호출한다.

                    let text;                           //text를 선언
                    if (isNaN(x) || x < 1 || x > 10) {      //입력받은 값이 1<입력값 <10인지 확인하여 유효성 검사
                        text = "Input not valid";           //실제 서비스에서는 값이 맞을 때, 백엔드 서버로 해당 값을 전달하는 방식으로 활용가능
                    } else {
                        text = "Input OK";
                    }
                    document.getElementById("demo").innerHTML = text;
                }
            </script>
        </body>
        </html> 
    
    7) DOM CSS 변경
        형식:
            document.getElementById(id).style.property = new style
        
        ex)
            <html>
            <body>
                <p id="p2">Hello World!</p>

                <script>
                    document.getElementById("p2").style.color = "blue";
                </script>
            </body>
            </html>

        html의 특정 element 클릭 시 작동하도록 기능 추가
        ex)
            <h1 id="id1">My Heading 1</h1>
            
            // onclick 이벤트 발생 시 element id가 "id1"인 값의 색을 변경
            <button type="button" onclick="document.getElementById('id1').style.color = 'red'"> 
            Click Me!</button>
    
    8) DOM Animation
        예시를 통해 사용법 습득 필요(적용 시 고려해야 할 부분 있음)

        ex)
            <html>
                <style>
                    #container {
                        width: 400px;
                        height: 400px;
                        position: relative;
                        background: yellow;
                    }
                    #animate {
                        width: 50px;
                        height: 50px;
                        position: absolute;
                        background-color: red;
                    }
                </style>
            <body>
                <p><button onclick="myMove()">Click Me</button></p> 

                <div id ="container">
                <div id ="animate"></div>
                </div>

                <script>
                    function myMove() {
                        let id = null;      //id 초기값 지정
                        const elem = document.getElementById("animate");    //animate라는 id를 가진 element를 호출 하여 elem에 지정
                        let pos = 0;                    // 위치 값pod의 초기화
                        clearInterval(id);              // claerInterval:   Interval 함수의 즉시 종료
                                                            // 값으로 id를 넣은 이유는 id 변수에 setInterval함수를 선언했기 때문
        
                        id = setInterval(frame, 5);     // 0.0005초 간격으로 frame을 실행

                        function frame() {      
                            if (pos == 350) {                   //350까지 이동하면 id값을 초기화(종착점)
                                clearInterval(id);              // claerInterval:   Interval 함수의 즉시 종료
                            } 
                            else {                              //top과 left의 위치 값에 ++1 처리
                                pos++; 
                                elem.style.top = pos + "px"; 
                                elem.style.left = pos + "px"; 
                            }
                        }
                    }
                </script>
            </body>
            </html>
    
    9) DOM Event
        html의 attribute를 활용해서 JS값을 입력할 수 있다.

        attribute 설정 방식:
            JS의 event를 propetry활용
                    Event	            Description
                    onchange	        html 엘리먼트가 바뀌었을 때
                    onclick	            html 엘리먼트를 클릭했을 때
                    onmouseover	        html 엘리먼트에 마우스를 올렸을 때
                    onmouseout	        html 엘리먼트에 마우스를 댔다가 떼었을 때
                    onkeydown	        사용자가 키보드 자판을 눌렀을 때
                    onload	            브라우져가 로딩을 다 끝냈을 때(페이지 생성을 다 끝냈을 때)

            9-1) property이용
            ex)
                <h1 onclick="this.innerHTML = 'Ooops!'">Click on this text!</h1>
            
            9-2) method이용
            ex)
                <h1 onclick="changeText(this)">Click on this text!</h1>     // this를 통해 현재 attribute가 위치한 element의 값을 ChangeText의 인자로 입력

                <script>
                    function changeText(id) {
                        id.innerHTML = "Ooops!";    //html child 값 지정
                    }
                </script>
         
            9-3) JS내부에서 처리
            ex)
                <body>
                    <h2>JavaScript HTML Events</h2>

                    <button id="myBtn">Try it</button>
                    <p id="demo"></p>

                    <script>
                        document.getElementById("myBtn").onclick = displayDate;     //onclick attribute 자체에 값을 주입하는 방식으로 함수이지만 객체처럼 ()을 사용하지 않는다.
                                                                                    // 애초에 html의 onclick attribite는 JS의 매서드이다.
                        function displayDate() {
                            document.getElementById("demo").innerHTML = Date();
                        }
                    </script>
                </body>

        10) Event Listener

        addEventListener()
            존재하고 있는 element를 overwriting할 필요 없이 존재하는 event handler를 활용할 수 있다.
            * 여러 Event를 하나의 element에 담아 실행할 수 있다.

            형식:
                element.addEventListener(event, function, useCapture)
                * useCapture 값은 defualt = false로 일반적으로는 비활성화되어 있다.
            
            ex)
                <html>
                <body>
                    <h2>JavaScript addEventListener()</h2>
                    <p>This example uses the addEventListener() method to add many events on the same button.</p>
                    <button id="myBtn">Try it</button>
                    <p id="demo"></p>

                    <script>
                        var x = document.getElementById("myBtn");           //객체 x에 myBtn 아이디를 가진 element를 부여
                        x.addEventListener("mouseover", myFunction);        //객체 x에 mouseover event를 추가
                        x.addEventListener("click", mySecondFunction);      //객체 x에 click event를 추가
                        x.addEventListener("mouseout", myThirdFunction);    //객체 x에 mouseout event를 추가

                        function myFunction() {
                            document.getElementById("demo").innerHTML += "Moused over!<br>";
                        }
                        function mySecondFunction() {
                            document.getElementById("demo").innerHTML += "Clicked!<br>";
                        }
                        function myThirdFunction() {
                            document.getElementById("demo").innerHTML += "Moused out!<br>";
                        }
                    </script>
                </body>
                </html>
        
        11) DOM Navigation

            DOM 구조는 기본적으로 HTML Element 요소 간의 상속관계를 나타낸다.
            즉, <html>   →  <head>      :root인 <html>의 firstChild
                         →  <body>      :root인 <html>의 secondChild
            
            따라서 Navigation 역시 DOM 내부의 각 요소(element) 간의 연결관계를 나타낸 것이다.

            동일한 element에 대해 접근하는 3가지 방법:
                1) id를 호출하는 방식(상속관계 활용x)
                    ex)
                        <html>
                        <body>
                            <h1 id="id01">My First Page</h1>
                            <p id="id02"></p>

                            <script>
                                document.getElementById("id02").innerHTML = document.getElementById("id01").innerHTML;
                            </script>
                        </body>
                        </html>

                2) property로 접근  :n번째Child.nodeValue 를 활용
                    ex)
                        <html>
                        <body>
                            <h1 id="id01">My First Page</h1>
                            <p id="id02"></p>

                            <script>
                                document.getElementById("id02").innerHTML = document.getElementById("id01").firstChild.nodeValue;
                            </script>
                        </body>
                        </html>
                
                3) 객체의 array index로 접근
                    ex)
                        <html>
                        <body>
                            <h1 id="id01">My First Page</h1>
                            <p id="id02">Hello!</p>

                            <script>
                                document.getElementById("id02").innerHTML = document.getElementById("id01").childNodes[0].nodeValue;
                            </script>
                        </body>
                        </html>

                * nodeName  :
                    property로써, 해당 node의 HTML Tag 이름을 반환
                    즉, <p>HelloM</p> 의 nodeName을 호출할 경우 "p"가 반환

                * nodeValue :
                    property로써, 해당 node의 value(실제 값)을 반환
                    즉, <p>HelloM</p> 의 nodeName을 호출할 경우 "Hello"가 반환

        12) DOM Nodes
            DOM의 구성요소인 Node를 추가하고 삭제하는 메서드

            Node만들기:
                * HTML Element만들기

                ex)
                <div id="div1">
                    <p id="p1">This is a paragraph.</p>
                    <p id="p2">This is another paragraph.</p>
                </div>

                <script>
                    const para = document.createElement("p");                   //para 객체에 <p> HTML 태그를 생성하여 선언
                    const node = document.createTextNode("This is new.");       //node 객체에 "This is new."라는 텍스트를 생성하여 선언
                    para.appendChild(node);                                     //para에 node를 Child로 추가(현 시점의 para: <p>"This is new."</p>)

                    const element = document.getElementById("div1");            //"div1"id를 가진 Element를 element 객체에 호출하여 선언
                    element.appendChild(para);                                  //element 객체에 para를 Child로 추가(현 시점의 para: <p>"This is new."</p>)
                </script>
            
            * appendChild만으로 HTML Tag의 내부에 값을 넣고, element 사이에 element를 넣을 수 있는 이유:
                HTML에서 각 Element를 node로 간주하여 상호 간의 parent와 child가 있는 것처럼, Element와 내부의 value도 node로 보고 상호 간의 parent와 child가 있는 것으로 본다.
                즉 모든 개체들이 parent - child 관계를 맺고 있다.
            
            Node 삭제하기:
                * remove할 때도 각 Node간의 관계를 활용해서 특정 node만을 삭제할 수도 있다.

                remove
                ex)
                    <div>
                        <p id="p1">This is a paragraph.</p>
                        <p id="p2">This is another paragraph.</p>
                    </div>

                    <script>
                        const elmnt = document.getElementById("p1"); elmnt.remove();
                    </script>



                removeChild
                ex)
                    <div id="div1">
                        <p id="p1">This is a paragraph.</p>
                        <p id="p2">This is another paragraph.</p>
                    </div>

                    <script>
                        const parent = document.getElementById("div1");     //객체 parent에 id가 "div1"인 element를 선언
                        const child = document.getElementById("p1");        //객체 child에 id가 "p1"인 element를 선언
                        parent.removeChild(child);                          //해당 객체의 child를 삭제
                    </script>

            Node 교체하기:

                * parent node를 지정한 뒤, child를 교체하는 방식으로 node를 교체한다.
                replaceChild(새로운 값, 바꿀child값)
                ex)
                    <div id="div1">
                        <p id="p1">This is a paragraph.</p>
                        <p id="p2">This is another paragraph.</p>
                    </div>

                    <script>
                        const para = document.createElement("p");                   //para 객체에 <p> HTML 태그를 생성하여 선언
                        const node = document.createTextNode("This is new.");       //node 객체에 "This is new."라는 텍스트를 생성하여 선언
                        para.appendChild(node);                                     //para에 node를 Child로 추가(현 시점의 para: <p>"This is new."</p>)

                        const parent = document.getElementById("div1");             //"div1"id를 가진 Element를 parent 객체에 호출하여 선언
                        const child = document.getElementById("p1");                //child 객체에 id가 "p1"인 element를 호출하여 선언
                        parent.replaceChild(para, child);                           //replaceChild의 인자로 각각 para(새로 넣을 값)  child(바뀔 대상)을 넣기
                    </script>

        13) DOM Collections

            length 메서드:
                해당 element의 child 값의 수를 반환
                * 주로 반복문과 함께 쓰여, 해당 값의 child값(value)의 상태를 바꾸는 데에 활용한다.

                ex)
                    <html>
                    <body>
                        <h2>JavaScript HTML DOM</h2>

                        <p>Hello World!</p>
                        <p>Hello Norway!</p>
                        <p>Click the button to change the color of all p elements.</p>

                        <button onclick="myFunction()">Try it</button>

                        <script>
                            function myFunction() {
                                const myCollection = document.getElementsByTagName("p");        
                                for (let i = 0; i < myCollection.length; i++) {                 //myCollection에 담긴 <p>~</p>의 모든 child 값의 CSS 색이 red로 바뀐다.
                                    myCollection[i].style.color = "red";                        //각 child의 문자 하나하나를 indexing하여 호출할 수 있다.
                                }
                            }
                        </script>
                    </body>
                    </html>

            * nodelist와 array는 조금 다르다.
                array의 메서드들을 활용할 수 없다.(valueOf(), push(), pop(), join())

BOM 
    Browser Object Model

    1) window object
        브라우져의 윈도우 관련 기능 제공 객체
        * 기본적으로 DOM은 BOM 위에서 구동된다고 볼 수 있다.

        window.document.getElementById("header");
        document.getElementById("header");

        두 코드는 동일한 기능을 수행
        * document가 애초에 window의 property라고 브라우져와 JS는 약속

        1-1) window size
            window.innerHeight  :윈도우 브라우져의 내부 높이 값을 수치로 반환(세로)
            window.innerWidth  :윈도우 브라우져의 내부 길이 값을 수치로 반환(가로)

        1-2) window.open()  :새로운 브라우져 창을 생성

        1-3) window.close() :현재 브라우져 창을 닫기

        1-4) window.moveTo() :현재 브라우져 창을 이동

        1-5) window.resizeTo()  :현재 브라우져 창의 크기를 재조정

    2) screen
        사용자 기기의 창 크기를  px 단위의 수치로 반환(디스플레이 크기)

        screen.width        :가로 길이
        screen.height       :세로 길이
        screen.availWidth   :window의 taskbar등 사용할 수 없는 부분을 제외하고 실제 디바이스 화면의 가로 값을 px로 반환
        screen.availHeight  :window의 taskbar등 사용할 수 없는 부분을 제외하고 실제 디바이스 화면의 세로 값을 px로 반환
        screen.colorDepth   :사용자 디바이스의 해상도 값을 반환(색채)
        screen.pixelDepth   :사용자 디바이스의 해상도 값을 반환(해상도 자체)

    
    3) location
        위치가 사용자 디바이스의 위치가 아니라, 브라우져 내에서의 "위치"를 의미

        window.location.href    :현재 페이지(html문서)의 url을 반환
        window.location.hostname    :domain 이름을 반환 *웹 프로토콜의 값은 제외하고 "도메인/ip값"만 반환
        window.location.pathname    :html문서가 위치한 경로값(파일 경로값)을 반환
        window.location.protocol    :해당 html문서(url)의 웹 프로토콜이 "http"인지 "https"인지를 반환
        window.location.assign()    :새로운 문서(html)을 생성

    4) history
        웹 페이지의 이력에 대한 반환 값을 설정

        history.back()  :이전 방문 페이지로 이동
        history.forward()   :앞서 방문한 페이지로 이동
    
    5) popup box

        5-1) alert()
        팝업이 뜨는 형태

        window.alert()
        alert()
        * window를 생략해도 동일한 기능 수행

        ex)
            alert("I am an alert box!");
        
        5-2) prompt box
        팝업이 뜨며, 값을 사용자가 입력하여 html에 반영도 할 수 있는 기능

        window.prompt("노출할 텍스트", "엽력받을 값의 기본값");

        ex)
            <body>
                <button onclick="myFunction()">Try it</button>
                <p id="demo"></p>

                <script>
                    function myFunction() {
                        let text;
                        let person = prompt("Please enter your name:", "gainyunn");    //초기 default값으로는 Againyunn

                        if (person == null || person == "") {                           //값을 입력하지 않았을 경우
                            text = "User cancelled the prompt.";                    
                        } else {
                            text = "Hello " + person + "! How are you today?";        
                        }
                        document.getElementById("demo").innerHTML = text;               //HTML DOM
                    }
                </script>
            </body>

        * line break(한줄 띄기)
            \n  처리
            ex)
                alert("Hello\nHow are you?");
        
    6) Timing Event
        window.setTimeout(객체, 밀리초)     //밀리초 이후에 객체를 1번 실행
        window.setInterval(객체, 밀리초)    //밀리초 단위로 객체를 반복 실행

        * window를 생략해도 정상 작동(앞선 JS 보충 부분에서 학습)
    
    7) cookies
        웹 브라우져에 (사용자의) 정보를 기록

        7-1) create cookies
            document.cookie = "저장할 정보"활용

            ex)
                일반적인 쿠키 생성
                document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC";  //username이라는 정보에 John Doe 입력, 만료시각 설정

                특정 페이지에 쿠키 생성
                document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC; path=/";       //username이라는 정보에 John Doe 입력, 만료시각, 해당 쿠키가 저장될 html파일 위치 설정
        
        7-2) read cookies
            객체 = document.cookie;        //document.cookie 를 호출하면 객체가 반환

        
        7-3) change cookies
            쿠키를 생성(7-1)과 동일하게 쿠키를 생성하듯 정보를 입력하면 자동으로 overwriting 된다.

        7-4) delete cookie
            쿠키 삭제 시에는 쿠키의 기한 만료 시각을 기록하면 된다.

            ex)
                document.cookie = "username=John Doe; expires=Thu, 01 Dec 2000 00:00:00 UTC";           //이미 지난 시점을 쿠키 만료일로 설정하면, 자동으로 쿠키가 삭제된다.

Web APIs
    API :Application Programming Interface
        API를 통해 특정 웹 브라우져의 기능을 확장가능
        API를 통해 특정 서버의 기능을 확장가능
    

    1) Form :API 사용 형식
        checkValidity()     :입력받은 객체가 유효한 데이터를 가지고 있을 때 true를 반환
        setCustomValidity() :입력받은 객체에 대한 유효성 검사 메시지 property를 설정

        ex)
        * 예시를 통해 사용방법 습득하기
            <!DOCTYPE html>
            <html>
            <body>

                <h2>JavaScript Validation</h2>

                <p>Enter a number and click OK:</p>

                <input id="id1" type="number" min="100" max="300" required>                 //input data에 대한 validity 설정(number, 100~300까지의 값만 허용)
                <button onclick="myFunction()">OK</button>

                <p>If the number is less than 100 or greater than 300, an error message will be displayed.</p>

                <p id="demo"></p>

                <script>
                    function myFunction() {
                        const inpObj = document.getElementById("id1");

                        if (!inpObj.checkValidity()) {                                             //객체인 inpObj에 지정된 data validity를 검사했을 때 false값이 반환되는 경우
                            document.getElementById("demo").innerHTML = inpObj.validationMessage;   //유효하지 않다는 메시지 전달
                        } else {
                            document.getElementById("demo").innerHTML = "Input OK";                 //입력받은 값이 올바름을 반환
                        } 
                    } 
                </script>

            </body>
            </html>

        유효성 DOM properties
            
            Property	            Description
            validity	            입력받은 값에 대한 유효성을 검사하여 boolean값 반환
            validationMessage	    유효성 검사 시 false값 반환 시 오류 메시지 반환
            willValidate	        입력받은 값에 대한 유효성 검사별과를 타나낼 지 나타내는 값

        유효성 properties
            
            Property	            Description
            customError	            Set to true, if a custom validity message is set.
            patternMismatch	        Set to true, if an element's value does not match its pattern attribute.
            rangeOverflow	        Set to true, if an element's value is greater than its max attribute.
            rangeUnderflow	        Set to true, if an element's value is less than its min attribute.
            stepMismatch	        Set to true, if an element's value is invalid per its step attribute.
            tooLong	                Set to true, if an element's value exceeds its maxLength attribute.
            typeMismatch	        Set to true, if an element's value is invalid per its type attribute.
            valueMissing	        Set to true, if an element (with a required attribute) has no value.
            valid	                Set to true, if an element's value is valid.
        
            ex)
                <html>
                <body>

                    <h2>JavaScript Validation</h2>

                    <p>Enter a number and click OK:</p>

                    <input id="id1" type="number" max="100">
                    <button onclick="myFunction()">OK</button>

                    <p>If the number is greater than 100 (the input's max attribute), an error message will be displayed.</p>

                    <p id="demo"></p>

                    <script>
                        function myFunction() {
                            let text;
                            if (document.getElementById("id1").validity.rangeOverflow) {
                                text = "Value too large";
                            } else {
                                text = "Input OK";
                            } 
                            document.getElementById("demo").innerHTML = text;
                        }
                    </script>

                </body>
                </html>

    2) history API
        Web history API를 통해 windows.history를 쉽게 활용가능

        Property	    Description
        length	        웹 방문 기록의 수를 반환

        
        Method	        Description
        back()	        이전에 방문한 웹 사이트를 반환
        forward()	    앞서 방문한 웹 사이트를 반환
        go()	        웹 방문 기록 중 특정한 url로 이동(숫자를 인자로 받아서, history lists 중 index를 지정할 수 있다.)
    

            ex)
                <button onclick="myFunction()">Go Back 2 Pages</button>

                <script>
                    function myFunction() {
                        window.history.go(-2);
                    }
                </script>
    
    3) storage API

        3-1) Local storage object       : 로컬 영역에 저장하므로 브라우져(창)이 닫혀도 데이터는 유지된다.(만료 기한x)
            localStorage.setItem("key", "value")  : key와 value 쌍을 가진 객체를 localstorage에 생성 및 저장
            
            localStorage.getItem("key")     :key값에 해당하는 value 값을 반환

            localStorage.removeItem("key")  :key값에 해당하는 객체를 삭제

        
        3-2) sessionStorage object      : 세션 형태로 저장하여, 브라우져(창)이 닫혔을 때, 데이터도 삭제된다.
            sessionStorage.setItem("key", "value")  : key와 value 쌍을 가진 객체를 세션으로 생성 및 저장

            sessionStorage.getItem("key")       :key값에 해당하는 value 값을 반환

            sessionStorage.removeItem("key")  :key값에 해당하는 객체를 삭제
        
        3-3) properties와 methods

            Property/Method	                Description
            key(n)	                        Returns the name of the nth key in the storage
            length	                        Returns the number of data items stored in the Storage object
            getItem(keyname)	            Returns the value of the specified key name
            setItem(keyname, value)	        Adds that key to the storage, or update that key's value if it already exists
            removeItem(keyname)	            Removes that key from the storage
            clear()	                        Empty all key out of the storage

    4) Worker API
        Web Worker:
            HTML 페이지 외부에서 독립적으로 작동하는 JS파일 내의 동작
            백엔드의 작업 일부가 JS에서 작동한다고 보면된다.

            방법:
                1. web worker file 생성
                    이때, JS파일은 HTML 페이지 내부가 아닌, 새로운 JS형식의 파일을 생성하여 동작 로직을 구축한다.
                    * 일반적으로 Worker로 작동하는 연산은 간단한 script 연산이 아닌, CPU를 사용하는 복잡한 연산일 경우에 사용한다.
                      (백엔드의 연산을 JS로 분산하여 작업한다고 생각하면 편할 것으로 보인다.)
                
                2. HTML파일 내에서 worker 실행
                    ex)
                        if (typeof(w) == "undefined") {
                            w = new Worker("worker파일 명.js");         //객체 w 에 Worker를 선언, 이때 worker의 대상인 JS파일의 경로 입력
                        }
                    
                        w.workerMethod = function(event){               //객체 w의 메서드를 html 문서로 반환하는 함수, 인자로 event를 받고 이 event인자를 html 데이터로 반환
                            document.getElementById("result").innerHTML = event.data;
                        };

                        w.terminate();          //객체 w의 동작을 정지
                        w = undefined;          //객체 w를 undefined로 초기화(새로운 worker나 다른 값으로 활용할 수 있도록 초기화)
                    
    5) Geolocation API 
        사용자의 현재 위치를 html에 반환하는 API

        getCurrentPosition() 

        ex)
            <script>
                const x = document.getElementById("demo");
                function getLocation() {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(showPosition);
                    } 
                    else {
                        x.innerHTML = "Geolocation is not supported by this browser.";
                    }
                }

                function showPosition(position) {
                    x.innerHTML = "Latitude: " + position.coords.latitude +
                    "<br>Longitude: " + position.coords.longitude;
                }
            </script>
        
        실제 서비스에 반영할 경우 googlemap, navermap, kakaomap등 외부 map API를 활용해야 한다.
    
AJAX
    Asynchronous JavaScript And XML
    AJAX는 프로그래밍 언어가 아니다.
    AJAX를 활용할 경우: 
        1) XMLHttpRequest의 객체로 사용
        2) JavaScriptdhk HTML DOM
    
    작동방식: HTML page에 호출되는 데이터를 담아 직접 재로딩하는 것이 아니라, JS로 XMLHttpRequest를 server로 전달하고 호출되는 데이터를 JS로 담아 현 페이지에서 데이터를 반환
                (페이지가 그대로 유지)
    
    1) XMLHttpRequest Object
        AJAX의 핵심 4가지
            1. XMLHttpRequest 객체 생성
            2. callback함수를 정의
            3. XMLHttpRequest 열기
            4. Server에 Reauet 전송
        

        * XMLHttpRequest는 화면 뒤에서 server와 데이터를 교환할 수 있다는 특성이 있다.

        1-1) XMLHttpRequest 객체 생성:
            variable = new XMLHttpRequest();    //XMLHttpRequest객체를 새롭게 선언


        1-2) callback 함수 정의:
            xhttp.onload = () => {
                비동기식 데이터 처리 후 사용할 함수의 기능 정의
            }
    
        1-3) Request 전송:
            xhttp.open("GET", "가져올 데이터 항목");
            xhttp.send();

        * 브라우져들은 보안을 위해서, domain에 접근하는 것을 금지 한다.
        따라서 HTML Web 페이지와 XML 파일은 같은 server 내에 위치해야 한다.

        XMLHttpRequest 객체의 methods

            Method	                            Description
            new XMLHttpRequest()	            XMLHttpRequest 객체 생성
            abort()	                            현재 request를 삭제(취소)
            getAllResponseHeaders()	            header의 정보를 반환
            getResponseHeader()	                특정한 header의 정보를 반환
            
            open(method, url, async, user, psw)	request를 구체화
                                                method: request의 타입을 지정(GET / POST)
                                                url: 파일의 위치(파일 저장 위치)
                                                async: default는 true값 [ true (비동기식) or false (동기식)]
                                                user: (선택)유저 이름 
                                                psw: (선택)패스워드 

            send()	                            GET을 통해 request를 server로 전달

            send(string)	                    POST을 통해 request를 server로 전달

            setRequestHeader()	                전송하는 Data의 header에 label/value를 header에 넣어 전달

        XMLHttpRequest 객체의 Properties

            Property	                        Description
            onload	                            request를 load할 때 실행할 동작(함수)
            onreadystatechange	                readyState가 변화함에 따라 동작할 기능을 함수로 지정

            readyState	                        Holds the status of the XMLHttpRequest.
                                                0: request가 초기화 되지 않음
                                                1: server와 연결된 상태
                                                2: request 수신 완료
                                                3: request 처리중
                                                4: request가 전달완료되었으며 response 도 준비된 경우

            responseText	                    response를 string 형태로 반환
            responseXML	                        response를 XML data형태로 반환
            status	                            request의 상태를 숫자 형태로 반환
                                                200: "OK"   (정상 수신)
                                                403: "Forbidden"    (접근 불가)
                                                404: "Not Found"    (페이지 삭제등의 문제로 찾을 수 없음)

            statusText	                        request의 상태가 "string"으로 반환 (e.g. "OK" or "Not Found")
        

        1-4) onload Property
            reponse받게 되면 실행할 동작(기능) 정의

            ex)
                <script>
                    xhttp.onload = function() {
                        document.getElementById("demo").innerHTML = this.responseText;
                    }
                    xhttp.open("GET", "ajax_info.txt");
                    xhttp.send();
                </script>

        1-5) 여러 개의 callback함수 활용
            html페이지에서 여러 번의 AJAX를 활용한 비동기식 데이터 송수신이 필요한 경우에, 
            각각의 AJAX task에 callback함수들을 부여할 수 있다.

            ex)
                loadDoc("url-1", myFunction1);

                loadDoc("url-2", myFunction2);

                function loadDoc(url, cFunction) {          //callback 함수를 위한 실행 함수
                    const xhttp = new XMLHttpRequest();

                    xhttp.onload = function() {
                            cFunction(this);
                        }

                    xhttp.open("GET", url);
                    xhttp.send();
                }

                function myFunction1(xhttp) {
                // action goes here
                }

                function myFunction2(xhttp) {
                // action goes here
                }

        1-6) onreadystatechange Property

            ex)
                function loadDoc() {
                    const xhttp = new XMLHttpRequest();

                    xhttp.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            document.getElementById("demo").innerHTML =
                            this.responseText;
                        }
                    };

                    xhttp.open("GET", "ajax_info.txt");
                    xhttp.send();
                }

    2) XMLHttpRequest
        GET과 POST의 사용 차이:
            일반적으로 GET이 POST보다 "간편하고 빠르다"

            POST만 사용하는 예외적인 상황:
                1. server의 파일이나 DB를 수정해야 하는 경우
                2. 많은 양의 데이터를 서버와 송수신해야 하는 경우(GET은 data의 용량 제한 존재, POST는 data의 용량제한x)
                3. 사용자의 정보를 송수신하는 경우(GET은 url외부로 데이터가 노출되므로)
            
        2-1) GET    

            ex) 일반적으로 GET을 활용할 때
                xhttp.open("GET", "demo_get.asp");
                xhttp.send();

            ex) cashed 된 결과를 제외하는 결과(데이터)를 수신해야 하는 경우
                * 매번의 requset 전송 때 독립적인 ID를 전송하는 url에 심는다.

                xhttp.open("GET", "demo_get.asp?t=" + Math.random());   //Math.random() 메서드로 매번의 요청마다 새로운 ID를 생성하여 요청
                xhttp.send();

            ex) 특정한 정로를 request에 담아서 보내는 경우

                xhttp.open("GET", "demo_get2.asp?fname=Henry&lname=Ford");
                xhttp.send();
            
        2-2) POST

            ex) 일반적으로  POST를 활용할 때
                xhttp.open("POST", "demo_post.asp");
                xhttp.send();
            
            ex) form 엘리먼트를 활용하여 입력받은 특정 정보를 전달할 때
                xhttp.open("POST", "ajax_test.asp");
                xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");    //header를 추가할 수 있다. 
                xhttp.send("fname=Henry&lname=Ford");   //전달하는 특정한 정보만을 지정할 수 있다.
            
            
            Method	                            Description
            setRequestHeader(header, value)	    request에 HTTP header를 추가
                                                header: specifies the header name
                                                value: specifies the header value
    
    3) Response
        Responde의 유형:
            responseText	response를 string 형태로 반환
            responseXML	    response를 XML data형태로 반환

        haeder info의 유형:
            * header정보를 받아, HTML의 header에 정보를 담을 수 있다.         
            Method	                    Description
            getResponseHeader()	        서버로부터 특정한 header info를 반환
            getAllResponseHeaders()	    서버로부터 모든 header info를 반환
        
    4) AJAX Database
        DB로부터 AJAX를 통해 결과값을 반환

        web framework의 백단에서 DB를 AJAX형태로 반환하는 코드를 통해 프론트로 받아올 수 있다.
    
JSON
    JavaScript Object Notation
    
    특징:
        data의 저장과 전송을위한 text format
        computer 사이에 data를 주고 받을 때 사용
        여러 프로그래밍 언어에서 인식(사용)될 수 있는 범용성 존재

    자기기술성을 가지고 있으며, 이해하기 쉽다
    * 자기기술성(DBMS로부터 데이터의 삽입과 삭제를 어떤 종속적 사항 없이 가능한 특성)

    JSON의 string 예시:
        '{"name":"John", "age":30, "car":null}'
        위의 예시에서 다룬 3가지 properties:    name,   age,    car
    
    JSON형태의 SB string을 JS에서 아래와 같이 인식 및 처리할 수 있다.
        let personName = obj.name;
        let personAge = obj.age;

    JSON과 JS 상호 간의 변환:
        1. JSON을 JS의 객체로 변환하는 명령어
            JSON.parse()
        
        2. JS를 JSON의 string으로 변환하는 명령어
            JSON.stringfy()
    
    1) JSON Syntax:
        기본 형식:
            1. Data는 name/value의 쌍을 갖는다.
            2. Data는 ,단위로 분리되어 있다.
            3. Data의 "객체"를 중괄호 { }가 감싸고 있다.
            4. 대괄호 [ ]가 배열들(객체들)을 감싸고 있다.

        JSON이 가질 수 있는 값(value):
            string
            number
            object
            array
            boolean
            null

        JSON이 XML보다 좋은 점:
            - XML이 JSON보다 읽기 어렵다(인식하기 어렵다.)
            - JSON은 JS의 객체로 사용하기 편리하다

    2) Data 처리
        JS에서 JSON의 data에 접근할 수 있는 방법:
            ex) person = [{"name":Againyunn"},{"age":26}]

            1) data의 인식:
                person.name;

                person["name"];

            2) data의 변경:
                person.name = "Lucas";

                person["name"] = "Lucas";


        JSON 객체 내부에서 array를 가지기:
            ex)
            person=[
                {       
                    "employees":["John", "Anna", "Peter"]       //person의 property로 array를 갖음 
                                                                //employees[0] = "John", employee[1] = "Anna", employee[2] = "Peter"
                },
                {"eName":"John"},                               
                {"eName":"Anna"},
                {"eName":"Peter"}
            ]
    3) Parse 처리   : JSON →  JS 변환
        
        3-1) JSON을 JS의 객체(object)로 변환
            ex) 
            예시 JSON구문 '{"name":"John", "age":30, "city":"New York"}'

            const obj = JSON.purse('{"name":"John", "age":30, "city":"New York"}');

        3-2) JSON의 array를 JS의 array로 변환
            ex)
            예시 JSON구문 '["Apple","Banana","Orange"]'
            const myArr = JSON.purse('["Apple","Banana","Orange"]');

        * 예외 상황:
            Dates형태의 데이터는 JSON에서 인식하지 못한다. 
            따라서 JSON에서 "String"형태로 입력한 뒤, JS의 객체로 반환하면 Dates의 형태로 반환된다.

            ex)
                const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
                const obj = JSON.parse(text);               
                  if (key == "birth") {
                        return new Date(value);     //JS의 Dates 형태의 데이터로 정제하기 위하여, obj의 birth property를 Date형태로 변환
                    } else {
                        return value;
                    }           
                document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth;

    4) Stringfy 처리    : JS → JSON 변환

        4-1) JS을 JSON으로 변환
            ex)
                const obj = {name: "John", age: 30, city: "New York"};
                const myJSON = JSON.stringify(obj);        
                                // [{"name":"John"},{"age":30},{"city":"New York"}]의 JSON으로 변환
        
        4-2) JS의 array를 JSON의 string형태의 array로 변환
            ex)
                const arr = ["John", "Peter", "Sally", "Jane"];
                const myJSON = JSON.stringify(arr);
        
        * 예외 상황:
            JSON은 date의 데이터 형식을 처리하지 못하기 때문에 date형태의 데이터 형식을 string으로 바꾸어 인식

            ex)
                const obj = {name: "John", today: new Date(), city : "New York"};
                const myJSON = JSON.stringify(obj);
    
    5) JSON Objects
        5-1) Objcet value(값) 호출
            const myJSON = '{"name":"John", "age":30, "car":null}';
            const myObj = JSON.parse(myJSON);
            x = myObj.name;
            y = myObj["name"];
            //x와 y의 결과 값은 동일하다.
        
        5-2) Looping Objects
            ex) name(key)값 반환
                const myJSON = '{"name":"John", "age":30, "car":null}';
                const myObj = JSON.parse(myJSON);

                let text = "";
                for (const x in myObj) {
                    text += x + ", ";
                }
                //name, age, car

            ex) value값 반환
                const myJSON = '{"name":"John", "age":30, "car":null}';
                const myObj = JSON.parse(myJSON);

                let text = "";
                for (const x in myObj) {
                    text += myObj[x] + ", ";
                }
                //John, 30, null
            
    6) HTML Table
        JSON의 결과를 HTML에 표시하는 방법
            ex)
                <html>
                <body>

                    <h2>Make a table based on the value of a drop down menu.</h2>

                    <select id="myselect" onchange="change_myselect(this.value)">       //선택항목을 변경하면 해당 value에 해당 하는 값을 JS의 change_myselect 함수의 인자로 전달
                        <option value="">Choose an option:</option>
                        <option value="customers">Customers</option>
                        <option value="products">Products</option>
                        <option value="suppliers">Suppliers</option>
                    </select>

                    <p id="demo"></p>

                    <script>
                        function change_myselect(sel) {
                            const dbParam = JSON.stringify({table:sel,limit:20});   //
                            const xmlhttp = new XMLHttpRequest();                   //XMLHttpRequest 객체 생성
                            xmlhttp.onload = function() {                           //response에 대한 동작 정의
                                myObj = JSON.parse(this.responseText);              //response받은 data를 JS로 변환
                                text = "<table border='1'>"
                                for (x in myObj) {                                  //data의 "name(key)"값을 Loop돌며 반환
                                    text += "<tr><td>" + myObj[x].name + "</td></tr>";
                                }
                                text += "</table>"    
                                document.getElementById("demo").innerHTML = text;   //html로 출력
                            }
                            xmlhttp.open("POST", "json_demo_html_table.php", true);     //XMLHttpRequestf를 POST형태로 요청하여 "json_demo_html_table.php"파일을 오픈
                            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");  //header의 정보도 수신받도록 지정
                            xmlhttp.send("x=" + dbParam);                               //요청하는 POST형태의 정보값을 지정
                        }
                    </script>

                </body>
                </html>


                    

